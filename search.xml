<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue入门学习</title>
      <link href="/2021/09/07/vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/09/07/vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue的使用"><a href="#Vue的使用" class="headerlink" title="Vue的使用"></a>Vue的使用</h2><h4 id="挂载vue实例的两种方法"><a href="#挂载vue实例的两种方法" class="headerlink" title="挂载vue实例的两种方法"></a>挂载vue实例的两种方法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  const app = new Vue(&#123;</span><br><span class="line">  //第一种通过options挂载</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: &#x27;&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    //第二种通过$mount挂载</span><br><span class="line">app.$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>第二种能更好的对vue进行操作</p><p>如:</p><p>​        延时几秒后在页面挂载vue实例</p><h4 id="数据绑定v-bind"><a href="#数据绑定v-bind" class="headerlink" title="数据绑定v-bind"></a>数据绑定v-bind</h4><p>作用:动态给DOM绑定属性</p><p>常用:动态绑定属性 给子组件传递数据</p><h4 id="事件处理v-on"><a href="#事件处理v-on" class="headerlink" title="事件处理v-on"></a>事件处理v-on</h4><p>作用:监听DOM事件</p><p>常用:绑定点击事件 绑定键盘触发事件</p><p><strong>v-on事件修饰符</strong></p><ul><li>.stop：阻止单击事件冒泡</li><li>.prevent：阻止默认事件</li><li>.capture：使用事件捕获模式(点击嵌套事件时 由外向内)</li><li>.self：只当在 event.target 是当前元素自身时触发处理函数，即事件不是从内部元素触发的</li><li>.once：事件只触发一次</li><li>.passive：事件行为默认执行 不用等待回调</li></ul><h4 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h4><p><strong>v-text</strong></p><p>格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 v-text=&quot;str&quot;&gt;123&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>作用：将str的内容替换掉h2的内容</p><p>v-text和插值语法的区别：v-text会替换掉整个h2的内容 而插值语法不会</p><p><strong>v-html</strong></p><p>格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 v-text=&quot;str&quot;&gt;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>作用：v-html支持结构的解析 也就是说str含有页面标签同样生效</p><p>v-html和v-text的区别：v-html支持结构解析(存在安全性问题)</p><p><strong>v-cloak</strong></p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 v-cloak&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>作用：解决页面js还没加载完时候未解析时 对未被Vue解析的h2进行处理</p><p>原理：Vue未解析h2内的插值语法时存在v-cloack属性 解析完成之后移除该属性</p><p>常用于Vue未解析插值语法时 隐藏真实DOM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  [v-cloak]&#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>v-once</strong></p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 v-once&gt;&#123;&#123;n&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=&quot;n++&quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>作用：添加的v-once的节点 初次动态渲染后 后续都为静态内容 因此后续n的变化 不会引起v-once所在结构的更新 有利于提高性能</p><p><strong>v-pre</strong></p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 v-pre&gt;你好&lt;/h2&gt;</span><br><span class="line">&lt;button v-pre&gt;你好啊:&#123;&#123;name&#125;&#125;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>作用：跳过v-pre所在节点的编译过程 说白了就是Vue直接不解析含有v-pre属性的节点 提高性能</p><h4 id="计算机属性computed"><a href="#计算机属性computed" class="headerlink" title="计算机属性computed"></a>计算机属性computed</h4><p>使用前提：需要有属性 才能进行加工</p><p>原理：底层借助了Object.defineproperty方法提供的getter和setter</p><p>特点：当属性发生变化时(模板重新渲染时)会自动调用</p><p>computed有getter和setter 前者获取初始值 后者所获取的初始值发生改变时调用</p><p><strong>computed的优势</strong></p><p>与methods实现相比 内部有缓存机制 效率更高 调试方便</p><h4 id="监视属性watch"><a href="#监视属性watch" class="headerlink" title="监视属性watch"></a>监视属性watch</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">  //监视属性</span><br><span class="line">  message:&#123;</span><br><span class="line">    //开启深度监视</span><br><span class="line">    deep:true,</span><br><span class="line">    //页面一加载立刻调用handle</span><br><span class="line">    immediate:true,</span><br><span class="line">    //发生改变时调用</span><br><span class="line">    handle(newValue,oldValue)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深度监视使用的常见情况：监听一个包含多个对象的数组 数组对象属性发生改变 但watch不触发 此时就需要使用深度监视</p><p>watch对比computed：Computed不能进行异步操作(无法对返回值进行操作)</p><h4 id="绑定class样式"><a href="#绑定class样式" class="headerlink" title="绑定class样式"></a>绑定class样式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--对象写法--&gt;</span><br><span class="line">&lt;div :class=&quot;&#123;&#x27;show&#x27;:true,color:true&#125;&quot;&gt;动态绑定class对象写法&lt;/div&gt;</span><br><span class="line">&lt;!--数组写法--&gt;</span><br><span class="line">&lt;div :class=&quot;[&#x27;show&#x27;,&#x27;color&#x27;]&quot;&gt;动态绑定class数组写法&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>对象绑定：能够通过布尔值决定是否绑定class样式(常用)</li><li>数组绑定：传递一个数组能够将数组中的全部class绑定</li></ul><h4 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--对象写法--&gt;</span><br><span class="line">&lt;div :style=&quot;&#123;display:&#x27;none&#x27;&#125;&quot;&gt;动态绑定style对象写法&lt;/div&gt;</span><br><span class="line">&lt;!--数组写法--&gt;</span><br><span class="line">&lt;div :style=&quot;[&#123;color:&#x27;red&#x27;&#125;,&#123;background:&#x27;black&#x27;&#125;]&quot;&gt;动态绑定style数组写法&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>对象绑定：通过{属性名:属性值}进行style绑定</li><li>数组绑定：存放多个样式对象</li><li>注意： 如果属性名为background-color这类中间有横杠的 属性名需加单标签或者使用驼峰命名法</li></ul><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--条件渲染全家套餐--&gt;</span><br><span class="line">&lt;div v-if=&quot;Boolean&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;Boolean&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>注意：使用多个条件渲染时 中间不能被其他DOM元素隔开 否则后续的分组无效</li><li>v-if和v-show的区别：<ul><li>v-show总是会进行渲染（能获取到真实DOM）隐藏与显示只是通过display属性进行实现</li><li>v-if只有在布尔值为true的时候才会进行渲染 </li></ul></li></ul><h4 id="列表渲染v-for"><a href="#列表渲染v-for" class="headerlink" title="列表渲染v-for"></a>列表渲染v-for</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;(item,index) in arr&quot; :key=&quot;item&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>v-for<ul><li>遍历的次数由index决定</li><li>遍历数组：item为数组元素</li><li>遍历对象：item为属性值</li></ul></li><li>key<ul><li>key值不存在于真实DOM中 只存在于虚拟DOM中 作用也只是进行diff算法比较的标志</li><li>key值不填写的时候默认使用index为key</li></ul></li></ul><p><strong>列表过滤</strong></p><p>vue中如果通索引对数组数据进行修改 vue不会重新进行模板渲染</p><p>因此需要下述的这些方法 来实现修改数组的功能</p><ol><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ol><h4 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set()"></a>Vue.set()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;)//往data的student对象中添加 属性名为sex 属性值为男的属性</span><br></pre></td></tr></table></figure><p>作用：解决往vm和_data中_中添加新属性 页面无法及时渲染的情况</p><p>ps：该方法无法对直接往data里面添加属性</p><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  upCase(value)&#123;</span><br><span class="line">    return value.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;str | upCase&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>全局过滤器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(&#x27;toUp&#x27;,function (value) &#123;</span><br><span class="line">  return value.toUpperCase()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>ps：过滤器可以用在插值语法和v-bind中</p><p>ps：过滤器中的this是window</p><h4 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--双向绑定--&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br></pre></td></tr></table></figure><p>注意：绑定时单选框、复选框、下拉列表选框等 需要添加value值才能实现双向绑定 对复选框进行双向绑定时返回值为数组</p><p><strong>修饰符</strong></p><ul><li>.lazy<ul><li>使用场景：当文本输入时不想每输入一个字符 更新一次影响内存</li><li>作用：在文本输入失去焦点时再更新一次数据</li></ul></li><li>.number：<ul><li>使用场景：在文本输入框中 无论输入的内容为字母还是数字 返回值都为字符串 </li><li>作用：只获取输入框的连续数字</li></ul></li><li>.trim<ul><li>作用：去掉空白</li></ul></li></ul><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p><strong>函数写法</strong></p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">directives:&#123;</span><br><span class="line">  big(element,binding)&#123;</span><br><span class="line">      return element.innerText = binding.value * 10</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps：element为真实DOM元素 binding为Vue绑定的相关属性</p><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;放大10倍之后的n值为:&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>big函数调用： 1.指令与元素成功绑定时会调用  2.指令所在所在的模板被重新解析时</p><p><strong>对象写法</strong></p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">directives:&#123;</span><br><span class="line">  &#x27;f-bind&#x27;:&#123;</span><br><span class="line">    //指令与元素成功绑定时</span><br><span class="line">    bind(element,binding) &#123;</span><br><span class="line">      console.log(this);//this为window对象</span><br><span class="line">      element.value = binding.value</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    //指令所在元素被插入页面时</span><br><span class="line">    inserted(element,binding) &#123;</span><br><span class="line">      element.focus()</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    //指令所在模板被重新解析时</span><br><span class="line">    update(element,binding) &#123;</span><br><span class="line">      element.value = binding.value</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-f-bind:value=&quot;n&quot;&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>获取Vue绑定的属性值 修改文本框value值与之相等</li><li>当真实DOM加载到页面时候 输入框获取焦点</li><li>当指令所在模板被重新解析（data中的数据发生变化等等情况）时  重新获取Vue绑定的属性值 修改文本框value值与之相等</li></ul><h4 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h4><p><strong>生命周期概念</strong></p><ol><li>生命周期又叫 生命周期回调函数、生命周期函数、生命周期钩子</li><li>Vue在关键时刻帮助我们调用一些特殊名称的函数</li><li>生命周期函数的名称不可修改 当函数的具体内容可以按照需求编写</li><li>在生命周期中的this指向的是vm 或 组件对象</li></ol><p><strong>生命周期的阶段</strong></p><p><img src="/images/vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/life.png"></p><h4 id="组件的基本使用"><a href="#组件的基本使用" class="headerlink" title="组件的基本使用"></a>组件的基本使用</h4><h5 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h5><p><strong>创建</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const school = Vue.extend(&#123;</span><br><span class="line">  template: `</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;学校名称: &#123;&#123;school.name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;学校地址: &#123;&#123;school.address&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      school:&#123;</span><br><span class="line">        name:&#x27;网院&#x27;,</span><br><span class="line">        address: &#x27;长沙&#x27;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注册</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#root&#x27;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      &#x27;xue-xiao&#x27;:school,</span><br><span class="line">      xuesheng:student</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">  &lt;xue-xiao&gt;&lt;/xuex-iao&gt;</span><br><span class="line">  &lt;xuesheng&gt;&lt;/xuesheng&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>template：</p><ul><li>组件的html模板</li></ul></li><li><p>组件data和vm data不相同的原因：</p><ul><li>vm只能存在一个 data中的数据因此只有自身调用 而<strong>组件能多次注册</strong></li><li> 因此组件中的数据会被共享 因此需要<strong>return</strong>给组件实例对象返回不同的地址值不同的数据</li></ul></li><li><p>注意：组件名可以使用vue命名规范xxx-xxx 也可以使用驼峰命名法xxxXxx(仅在脚手架中生效)</p></li></ul><h5 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//全局注册组件</span><br><span class="line">Vue.component(&#x27;xuexiao&#x27;,school)/</span><br></pre></td></tr></table></figure><h5 id="VueComponent"><a href="#VueComponent" class="headerlink" title="VueComponent"></a>VueComponent</h5><ul><li><p>上述案例的xue-xiao本质就是VueComponent的构造函数，且不是程序定义的，是Vue.extend生成的。</p></li><li><p>我们只需要写<xue-xiao></xue-xiao>或者<xue-xiao> Vue解析时会帮我们创建school组件实例对象</xue-xiao></p><p>即Vue帮我们执行：new VueComponent(options)</p></li><li><p>特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent</p></li><li><p>关于this指向：</p><ul><li>组件配置中：<ul><li>data函数、methods中的函数、watch只的函数、computed中的函数 他们的this均是<strong>VueComponent实例对象</strong></li></ul></li><li>new Vue()配置中：<ul><li>data函数、methods中的函数、watch只的函数、computed中的函数 他们的this均是<strong>Vue实例对象</strong></li></ul></li></ul></li></ul><p><strong>重要的内置关系</strong></p><ul><li>VueComponent.prototype.__proto === Vue.prototype</li><li>作用：让组件可以访问到Vue原型中的属性和方法</li></ul><p><strong>脚手架中main.js中的render</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将App作为真实DOM添加到页面中</span><br><span class="line">// render:h =&gt; h(App)</span><br><span class="line">//完整写法</span><br><span class="line">render:function (createElement) &#123;</span><br><span class="line">    return createElement(App)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚手架的vue不能解析template 因此需要render中的createElement来实现</p><p>脚手架中使用残缺的Vue的原因：Vue项目交给webpack打包后模板解析器就无效了 因此为了提高性能使用残缺的Vue</p><h4 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h4><p>作用：给html标签添加ref属性 可以通过$refs获取真实DOM属性  对真实DOM属性进行操作</p><p>​            给组件标签添加ref属性 可以获取组件实例对象</p><h4 id="nextTick方法"><a href="#nextTick方法" class="headerlink" title="$nextTick方法"></a>$nextTick方法</h4><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$nextTick(function () &#123;</span><br><span class="line">  this.$refs.edit.focus()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>作用：在方法体运行完解析了一遍模板之后 再调用$nextTick内的函数方法</p><h4 id="props配置"><a href="#props配置" class="headerlink" title="props配置"></a>props配置</h4><p>作用:</p><ol><li><p>给子组件传递数据</p><p>父组件传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;school :address=&quot;address&quot;/&gt;</span><br></pre></td></tr></table></figure><p>子组件获取传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//第一种方法获取传递参数</span><br><span class="line">// props:[&#x27;address&#x27;],</span><br><span class="line">//第二种方法获取传递参数</span><br><span class="line">props:&#123;</span><br><span class="line">  address:&#123;</span><br><span class="line">      type:String,</span><br><span class="line">      default：&#x27;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>给通过函数从子组件获取数据    </p></li></ol><p>ps：不建直接修改props里接收的数据 如需使用在data中定义个键来接收</p><h4 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h4><p>…</p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>…</p><h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><h5 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h5><p>父组件定义一个名为showMessage的自定义事件 调用的方法为message</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;school ref=&quot;school&quot; v-on:showMessage=&quot;message&quot;/&gt;</span><br></pre></td></tr></table></figure><p>子组件创建一个按钮 点击时候调用sendMessage方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;sendMessage&quot;&gt;点击传递message&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>子组件sendMessage方法 在调用时 通过$emit调用自定义事件showMessage 从而调用message方法 同时传递参数：’我叫张三 18岁 单身’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendMessage()&#123;</span><br><span class="line">    this.$emit(&#x27;showMessage&#x27;,&#x27;我叫张三 18岁 单身&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件message方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message(str)&#123;</span><br><span class="line">  console.log(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简写</strong></p><p>在mounted中添加下述代码也能实现同样效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$refs.school.$on(&#x27;showMessage&#x27;,this.message)</span><br></pre></td></tr></table></figure><p><strong>更简写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$refs.school.$on(&#x27;getName&#x27;,(name) =&gt; &#123;</span><br><span class="line">  this.schoolName = name</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>箭头函数中的this是父组件 如果不用箭头函数<strong>this为事件调用对象</strong>子组件</p><h5 id="解绑"><a href="#解绑" class="headerlink" title="解绑"></a>解绑</h5><p>在子组件中可以通过下述代码解绑自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$off(&#x27;getName&#x27;)</span><br></pre></td></tr></table></figure><p>解绑多个事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$off([&#x27;getName&#x27;,&#x27;getaddress&#x27;])</span><br></pre></td></tr></table></figure><p>解绑全部事件</p><p>this.$off()</p><p><strong>给组件绑定原生事件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;school ref=&quot;school&quot; @click.native=&quot;show&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$bus = this//安装全局事件总线</span><br></pre></td></tr></table></figure><p>绑定自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$bus.$on(&#x27;hello&#x27;,(data) =&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>触发自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$bus.$emit(&#x27;hello&#x27;,&#x27;张三&#x27;)</span><br></pre></td></tr></table></figure><p>解绑自定义事件（一般beforeDestroy中销毁）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$bus.off(&#x27;hello&#x27;)</span><br></pre></td></tr></table></figure><h4 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h4><p><strong>pubsub</strong></p><p>安装：npm i pubsub-js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//订阅消息</span><br><span class="line">const pubId = pubsub.subscribe(&#x27;hello&#x27;,function (message) &#123;</span><br><span class="line">  console.log(message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//发布消息</span><br><span class="line">pubsub.publish(&#x27;hello&#x27;,&#x27;message&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//取消订阅</span><br><span class="line">pubsub.unsubscribe(pubId)</span><br></pre></td></tr></table></figure><h4 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h4><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot; appear&gt;</span><br><span class="line">  &lt;h1 v-show=&quot;isShow&quot; &gt;你好啊!&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><p>样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.hello-enter-active&#123;</span><br><span class="line">  animation: move linear 1s;</span><br><span class="line">&#125;</span><br><span class="line">.hello-leave-active&#123;</span><br><span class="line">  animation: move linear 1s reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class名为固定的格式 首位单词由name决定当没设置name时默认为v</p><p>多个过度元素写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition-group name=&quot;hello&quot; appear&gt;</span><br><span class="line">  &lt;h1 v-show=&quot;isShow&quot; key=&quot;1&quot;&gt;你好啊!&lt;/h1&gt;</span><br><span class="line">  &lt;h1 v-show=&quot;!isShow&quot; key=&quot;2&quot;&gt;你好啊!&lt;/h1&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br></pre></td></tr></table></figure><p>多个过渡元素要使用<strong>transition-group</strong>标签同时要给标签内元素指定key值</p><h4 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h4><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*进入的起点*/</span><br><span class="line">/*离开的终点*/</span><br><span class="line">.hello-enter,.hello-leave-to&#123;</span><br><span class="line">  transform: translateX(-100%);</span><br><span class="line">&#125;</span><br><span class="line">/*进入过程*/</span><br><span class="line">/*离开过程*/</span><br><span class="line">.hello-enter-active,.hello-leave-active&#123;</span><br><span class="line">  transition: 0.5s linear;</span><br><span class="line">&#125;</span><br><span class="line">/*进入的终点*/</span><br><span class="line">/*离开的起点*/</span><br><span class="line">.hello-enter-to,.hello-leave&#123;</span><br><span class="line">  transform: translateX(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上述样式也能实现动画效果一样的效果</p><h4 id="第三方集成库"><a href="#第三方集成库" class="headerlink" title="第三方集成库"></a>第三方集成库</h4><p>官网：<a href="https://animate.style/">Animate.css | A cross-browser library of CSS animations.</a></p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install animate.css --save</span><br></pre></td></tr></table></figure><p>引用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;animate.css&#x27;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition-group</span><br><span class="line">        name=&quot;animate__animated animate__bounce&quot;</span><br><span class="line">        appear</span><br><span class="line">        enter-active-class=&quot;animate__swing&quot;&gt;</span><br><span class="line">  &lt;h1 v-show=&quot;isShow&quot; key=&quot;1&quot;&gt;你好啊!&lt;/h1&gt;</span><br><span class="line">  &lt;h1 v-show=&quot;!isShow&quot; key=&quot;2&quot;&gt;你好啊!&lt;/h1&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br></pre></td></tr></table></figure><p>name为固定写法</p><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><p><strong>安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i axios</span><br></pre></td></tr></table></figure><p><strong>引入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br></pre></td></tr></table></figure><p><strong>配置(在Vue配置文件中)：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//开启代理服务器一</span><br><span class="line">// devServer:&#123;</span><br><span class="line">//   proxy:&#x27;http://localhost:4000&#x27;</span><br><span class="line">// &#125;,</span><br><span class="line">//开启代理服务器二</span><br><span class="line">devServer:&#123;</span><br><span class="line">  proxy:&#123;</span><br><span class="line">    &#x27;/atguigu&#x27;:&#123;</span><br><span class="line">      target:&#x27;http://localhost:5000&#x27;,//请求的接口地址</span><br><span class="line">      pathRewrite:&#123;&#x27;^/atguigu&#x27;:&#x27;&#x27;&#125;,//解决从接口中请求错路径的问题</span><br><span class="line">      ws:true,//用于websocket</span><br><span class="line">      changeOrigin:true//</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>devServer可以解决接口跨域无法访问问题</p><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getStudents()&#123;</span><br><span class="line">  axios.get(&#x27;http://localhost:8080/atguigu/students&#x27;).then(</span><br><span class="line">          response =&gt; &#123;</span><br><span class="line">            console.log(response.data)</span><br><span class="line">          &#125;,</span><br><span class="line">          error =&gt; &#123;</span><br><span class="line">            console.log(error.data)</span><br><span class="line">          &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><h5 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h5><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;category title=&quot;游戏&quot; &gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">   &lt;li v-for=&quot;item in game&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line"> &lt;/ul&gt;</span><br><span class="line">&lt;/category&gt;</span><br></pre></td></tr></table></figure><p>组件内部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;category&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>在组件内部添加slot标签 就能给组件添加一个插槽 当在组件标签体内写的全部html内容都会添加到slot标签内 实现插槽的效果</p><p><strong>具名插槽</strong></p><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;category title=&quot;美食&quot; &gt;</span><br><span class="line"> &lt;div slot=&quot;first&quot;&gt;美食图片&lt;/div&gt;</span><br><span class="line"> &lt;div slot=&quot;second&quot;&gt;美食图片2&lt;/div&gt;</span><br><span class="line">&lt;/category&gt;</span><br></pre></td></tr></table></figure><p>组件内部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;category&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;</span><br><span class="line">    &lt;slot name=&quot;first&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;second&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>给组件内部的插槽添加一个name属性 再在组件标签内部的页面标签的slot属性中写入指定插槽的name就能实现具名插槽的效果</p><h5 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h5><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;category title=&quot;游戏&quot; &gt;</span><br><span class="line">  &lt;template scope=&quot;person&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;item in person.game&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/category&gt;</span><br></pre></td></tr></table></figure><p>组件内部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;category&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;</span><br><span class="line">    &lt;slot :game=&quot;[&#x27;穿越火线&#x27;,&#x27;qq飞车&#x27;,&#x27;CFHD&#x27;,&#x27;csol&#x27;,&#x27;300英雄&#x27;]&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>作用域插槽能够在父组件中调用子组件中传递的属性 可以随意指定scope属性名</p><p>ps：作用域插槽可以配合具名插槽使用 但不能配合插槽的新写法<code>v-slot:</code>使用</p><h5 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h5><p>在调用具名插槽时如果使用html标签 会添加一个无用的标签 因此更推荐下面的写法不会引入新的标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;category title=&quot;美食&quot; &gt;</span><br><span class="line">  &lt;template slot=&quot;first&quot;&gt;</span><br><span class="line">    美食图片</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  &lt;template v-slot:second&gt;</span><br><span class="line">    美食图片2</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/category&gt;</span><br></pre></td></tr></table></figure><p>v-slot:second 为template的具名插槽特殊写法 效果和第一种一样（ps：vue3之后只支持这种插槽写法）</p><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>当多个组件需要共享同一个数据时可以采用Vuex</p><p><strong>vuex原理图</strong></p><p><img src="/images/vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/vuex.png"></p><h5 id="搭载Vuex环境"><a href="#搭载Vuex环境" class="headerlink" title="搭载Vuex环境"></a>搭载Vuex环境</h5><ol><li>安装Vuex: npm i vuex</li><li>在src目录下建立 store/index.js目录</li><li>index.js内容为：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//该文件用于创建Vuex中最核心的store</span><br><span class="line">//导入Vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">//导入Vue</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">//使用Vuex插件</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">//准备action(服务员)用于响应组件动作</span><br><span class="line"> const actions = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  //准备mutations(厨师)用于操作数据(state)</span><br><span class="line">  const mutations = &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">  //准备state(菜品)用于存储数据</span><br><span class="line">  const state = &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //创建store</span><br><span class="line">  const store = new Vuex.Store(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  //导出store</span><br><span class="line">  export default store</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    4.在main.js中导入store并使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//导入store</span><br><span class="line">import store from &#x27;./store&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    //绑定挂载点</span><br><span class="line">    el:&#x27;#root&#x27;,</span><br><span class="line">    store,</span><br><span class="line">    router,</span><br></pre></td></tr></table></figure><h5 id="使用vuex"><a href="#使用vuex" class="headerlink" title="使用vuex"></a><strong>使用vuex</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//准备action(服务员)用于响应组件动作</span><br><span class="line"> const actions = &#123;</span><br><span class="line">  jia(context,value)&#123;</span><br><span class="line">    console.log(&#x27;actions被调用&#x27;)</span><br><span class="line">    context.commit(&#x27;JIA&#x27;,value)</span><br><span class="line">  &#125;,</span><br><span class="line">  jian(context,value)&#123;</span><br><span class="line">     console.log(&#x27;actions被调用&#x27;)</span><br><span class="line">     context.commit(&#x27;JIAN&#x27;,value)</span><br><span class="line">  &#125;,</span><br><span class="line">   jiaOdd(context,value)&#123;</span><br><span class="line">     console.log(&#x27;actions被调用&#x27;)</span><br><span class="line">     if (context.state.sum % 2)&#123;</span><br><span class="line">       context.commit(&#x27;JIA&#x27;,value)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   jiaWait(context,value)&#123;</span><br><span class="line">     console.log(&#x27;actions被调用&#x27;)</span><br><span class="line">     setTimeout(() =&gt; &#123;</span><br><span class="line">       context.commit(&#x27;JIA&#x27;,value)</span><br><span class="line">     &#125;,500)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  //准备mutations(厨师)用于操作数据(state)</span><br><span class="line">  const mutations = &#123;</span><br><span class="line">    JIA(state,value)&#123;</span><br><span class="line">      console.log(&#x27;mutations被调用&#x27;)</span><br><span class="line">      state.sum += value</span><br><span class="line">    &#125;,</span><br><span class="line">    JIAN(state,value)&#123;</span><br><span class="line">      console.log(&#x27;mutations被调用&#x27;)</span><br><span class="line">      state.sum -= value</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在文件中调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">decrement()&#123;</span><br><span class="line">  this.$store.commit(&#x27;JIAN&#x27;,this.addCount)</span><br><span class="line">&#125;,</span><br><span class="line">incrementOdd()&#123;</span><br><span class="line">  this.$store.dispatch(&#x27;jiaOdd&#x27;,this.addCount)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>commit方法是直接调用state中的数据</p><p>dispatch方法是通过actions和mutations 对state中的数据进行操作</p><h5 id="MapState和mapGetters"><a href="#MapState和mapGetters" class="headerlink" title="MapState和mapGetters"></a>MapState和mapGetters</h5><p>引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapState,mapGette&#125; from &#x27;vuex&#x27;</span><br></pre></td></tr></table></figure><p><strong>MapState</strong></p><p>使用在computed中</p><p>对象写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapState(&#123;getName:&#x27;name&#x27;,xuexiao:&#x27;school&#x27;&#125;)</span><br></pre></td></tr></table></figure><p>数组简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapState([&#x27;name&#x27;,&#x27;school&#x27;])</span><br></pre></td></tr></table></figure><p>效果相当于计算属性中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getName()&#123;</span><br><span class="line">  return this.$store.state.name</span><br><span class="line">&#125;,</span><br><span class="line">xuexiao()&#123;</span><br><span class="line">  return  this.$store.state.school</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapGetters</strong></p><p>使用在computed中</p><p>对象写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;),</span><br></pre></td></tr></table></figure><p>数组简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters([&#x27;bigSum&#x27;]),</span><br></pre></td></tr></table></figure><p>效果相当于计算属性中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bigSum()&#123;</span><br><span class="line">  return this.$store.getters.bigSum</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h5 id="mapAction和mapMutations"><a href="#mapAction和mapMutations" class="headerlink" title="mapAction和mapMutations"></a>mapAction和mapMutations</h5><p>引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapActions,mapMutations&#125; from &#x27;vuex&#x27;</span><br></pre></td></tr></table></figure><p><strong>mapMutations</strong></p><p>使用在methods中</p><p>对象写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),</span><br></pre></td></tr></table></figure><p>数组简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),</span><br></pre></td></tr></table></figure><p>对象写法效果相当于方法中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">increment(value)&#123;</span><br><span class="line">  this.$store.commit(&#x27;JIA&#x27;,value)</span><br><span class="line">&#125;,</span><br><span class="line">decrement(value)&#123;</span><br><span class="line">  this.$store.commit(&#x27;JIAN&#x27;,value)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>因此在调用这些方法中要传递data参数 否则回将event传递到mutations中无法达到预期结果</p><p><strong>mapAction</strong></p><p>使用在methods中</p><p>对象写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;),</span><br></pre></td></tr></table></figure><p>数组简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;]),</span><br></pre></td></tr></table></figure><p>对象写法效果相当于方法中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">incrementOdd(value)&#123;</span><br><span class="line">  this.$store.dispatch(&#x27;jiaOdd&#x27;,value)</span><br><span class="line">&#125;,</span><br><span class="line">incrementWait(value)&#123;</span><br><span class="line">  this.$store.dispatch(&#x27;jiaWait&#x27;,value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项和mapMutations相同</p><h5 id="vuex模块编码"><a href="#vuex模块编码" class="headerlink" title="vuex模块编码"></a>vuex模块编码</h5><p>作用：使vuex结构更清晰 更好进行管理</p><p>定义模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//求和相关配置</span><br><span class="line">const countOptions = &#123;</span><br><span class="line">  namespaced:true,//命名空间必写 不然程序无法识别</span><br><span class="line">  actions:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  state:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//人员管理相关配置</span><br><span class="line">const personOptions = &#123;</span><br><span class="line">  actions:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  state:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules:&#123;</span><br><span class="line">    countOptions,</span><br><span class="line">    personOptions</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用模块</p><p>methods中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//调用mutations中的方法</span><br><span class="line">...mapMutations(&#x27;countOptions&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),</span><br><span class="line">//调用action中的方法</span><br><span class="line">...mapActions(&#x27;countOptions&#x27;,[&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])</span><br></pre></td></tr></table></figure><p>computed中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//调用state中的方法</span><br><span class="line">...mapState(&#x27;countOptions&#x27;,[&#x27;sum&#x27;])</span><br></pre></td></tr></table></figure><p>一个选项为模块名称 第二个选项为调用的方法</p><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul><li><p><strong>安装</strong></p><p>npm i vue-router</p></li><li><p><strong>导入VueRouter</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &quot;vue-router&quot;;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用插件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure></li><li><p><strong>创建router</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &quot;vue-router&quot;;</span><br><span class="line"></span><br><span class="line">//导入组件</span><br><span class="line">import About from &quot;../view/About&quot;;</span><br><span class="line">import Home from &quot;../view/Home&quot;</span><br><span class="line"></span><br><span class="line">const routes=[</span><br><span class="line">  &#123;</span><br><span class="line">    path:&#x27;/about&#x27;,</span><br><span class="line">    component:About</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path:&#x27;/home&#x27;,</span><br><span class="line">    component:Home</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">export default new VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>使用router</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//导入router</span><br><span class="line">import router from &quot;./router&quot;;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure></li><li><p>正式使用</p><p>想要展示路由中的组件需要通过 router-view标签来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li><li><p>想要改变地址栏路径可以通过 router-link标签来实现（当然无论你用什么方法改变地址栏路由都能生效）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>组件router中的API使用</p><ul><li>push和replace</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//通过push进行页面跳转</span><br><span class="line">push(m)&#123;</span><br><span class="line">  this.$router.push(&#123;</span><br><span class="line">    path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">    query:&#123;</span><br><span class="line">      id:m.id,</span><br><span class="line">      title:m.title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">//通过replace进行页面跳转</span><br><span class="line">replace(m)&#123;</span><br><span class="line">  this.$router.replace(&#123;</span><br><span class="line">    path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">    query:&#123;</span><br><span class="line">      id:m.id,</span><br><span class="line">      title:m.title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>back、forward和go</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//后退</span><br><span class="line">back()&#123;</span><br><span class="line">  this.$router.back()</span><br><span class="line">&#125;,</span><br><span class="line">//前进</span><br><span class="line">forward()&#123;</span><br><span class="line">  this.$router.forward()</span><br><span class="line">&#125;,</span><br><span class="line">go()&#123;</span><br><span class="line">  //传递的n为正数时 为前进多少步 为负数时候 为后退多少步</span><br><span class="line">  this.$router.go(3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>路由中的两个新新生命周期钩子</p><ul><li><p>activated</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">activated() &#123;</span><br><span class="line">  //开启定时器</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>deactivated</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deactivated() &#123;</span><br><span class="line">  //关闭定时器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>作用：能够解决keep-alive导致定时器无法通过beforeDestroy销毁的问题</p></li></ul><h5 id="路由中的其他点"><a href="#路由中的其他点" class="headerlink" title="路由中的其他点"></a><strong>路由中的其他点</strong></h5><ul><li><p><strong>路由中组件的切换会引起其他路由组件的销毁</strong></p><p>此时就要通过keep-alive标签赖解决该问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=&quot;[&#x27;News&#x27;]&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>include指定不销毁的组件</p></li><li><p><strong>使用router Vue中新生成的两个属性route和router的作用</strong></p><p>router属性中 存储着当前路由对象调用的组件信息</p></li><li><p><strong>嵌套路由的使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path:&#x27;/home&#x27;,</span><br><span class="line">  component:Home,</span><br><span class="line">  children:[</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;news&#x27;,</span><br><span class="line">      component:News</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;message&#x27;,</span><br><span class="line">      component:Message</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>一级组件中的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h2&gt;我是Home的内容&lt;/h2&gt;</span><br><span class="line">  &lt;ul class=&quot;nav nav-tabs&quot;&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;router-link class=&quot;list-group-item&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;router-link class=&quot;list-group-item&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>路由传递参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;</span><br><span class="line">  path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">  query:&#123;</span><br><span class="line">    id:m.id,</span><br><span class="line">    title:m.title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><p>传递的参数可以通过router中的query接收</p></li><li><p><strong>路由中的params参数（对象写法中只能配合name使用 不能和path搭配使用）</strong></p><p>在路径中声明传递的参数名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path:&#x27;detail/:id/:title&#x27;,</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">to=&quot;/home/message/666/001&quot;</span><br></pre></td></tr></table></figure><p>可以在route的params属性中获取传递的参数</p></li><li><p><strong>路由中的props</strong></p><p>定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path:&#x27;detail/:id/:title&#x27;,</span><br><span class="line">component:Detail,</span><br><span class="line">//若布尔值为真 则会将该组件收到的所有params参数，以props的形式传递给Detail组件</span><br><span class="line">props:true</span><br></pre></td></tr></table></figure><p>传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;</span><br><span class="line">  name:&#x27;xiaoxiao&#x27;,</span><br><span class="line">  params:&#123;</span><br><span class="line">    id:m.id,</span><br><span class="line">    title:m.title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><p>接收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props:[&#x27;id&#x27;,&#x27;title&#x27;]</span><br></pre></td></tr></table></figure><p><strong>写法二</strong>（个人建议使用该写法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//函数写法 将该组件收到的所有query参数，以props的形式传递给Detail组件</span><br><span class="line">props(&#123;query&#125;)&#123;</span><br><span class="line">  return &#123;id:query.id,title:query.title&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递</p></li><li><p><strong>在<code>&lt;router-link repalce/&gt;</code> repalce的作用是替换当前记录 开启之后会导致不能回退</strong></p></li><li><p><strong>history模式与hash模式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode:history,//修改为history模式</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>区别：</p><ul><li>hash模式兼容性好一些</li><li>hash模式不会出现胡乱请求服务器资源的问题</li></ul></li></ul><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><h5 id="前置路由守卫"><a href="#前置路由守卫" class="headerlink" title="前置路由守卫"></a>前置路由守卫</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//全局前置路由守卫  初始化的时候被调用、每次路由切换之前被调用</span><br><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line">  //to和from中都有query和params 通过传递的值进行过滤操作</span><br><span class="line"></span><br><span class="line">  //如果想要去的路径为/home/news 对用户名进行判断</span><br><span class="line">  if(to.path === &#x27;/home/news&#x27;)&#123;</span><br><span class="line">    //获取浏览器保存的数据判断</span><br><span class="line">    if (localStorage.getItem(&#x27;name&#x27;) === &#x27;sans&#x27;)&#123;</span><br><span class="line">      next()//放行</span><br><span class="line">    &#125;</span><br><span class="line">    //其他请求放行</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>优化</strong></p><p>定义权限标记符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path:&#x27;news&#x27;,</span><br><span class="line">  component:News,</span><br><span class="line">  meta:&#123;isAuth:true&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>通过权限标记符进行过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(to.meta.isAuth)&#123;</span><br><span class="line">  //获取浏览器保存的数据判断</span><br><span class="line">  if (localStorage.getItem(&#x27;name&#x27;) === &#x27;sans&#x27;)&#123;</span><br><span class="line">    next()//放行</span><br><span class="line">  &#125;</span><br><span class="line">  //其他请求放行</span><br><span class="line">&#125;else &#123;</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后置路由守卫"><a href="#后置路由守卫" class="headerlink" title="后置路由守卫"></a>后置路由守卫</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to,form)=&gt;&#123;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>作用：可以在组件的meta中存储一个标题 当组件完成跳转后修改document.title为组件meta中的title</p><h4 id="独享路由守卫"><a href="#独享路由守卫" class="headerlink" title="独享路由守卫"></a>独享路由守卫</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path:&#x27;news&#x27;,</span><br><span class="line">  component:News,</span><br><span class="line">  meta:&#123;isAuth:true&#125;,</span><br><span class="line">  beforeEnter:(to,from,next) =&gt; &#123;</span><br><span class="line">  //处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果和beforeEach一样 不同点是 写在路径内部 只对该路径进行过滤处理</p><h4 id="组件内路由守卫"><a href="#组件内路由守卫" class="headerlink" title="组件内路由守卫"></a>组件内路由守卫</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &quot;About&quot;,</span><br><span class="line">  //通过路由规则 进入该组件时调用</span><br><span class="line">  beforeRouteEnter(to,from,next)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  //通过路由规则 离开该组件时被调用</span><br><span class="line">  beforeRouteLeave(to,from)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个都需要放行 beforeRouteLeave在路由组件切换时候才会调用</p><h2 id="Vue概念"><a href="#Vue概念" class="headerlink" title="Vue概念"></a>Vue概念</h2><h3 id="Vue的MVVM"><a href="#Vue的MVVM" class="headerlink" title="Vue的MVVM"></a>Vue的MVVM</h3><p>M 模型(model) ：对应data中的数据</p><p>V 视图(View) : 模板</p><p>VM 视图模型 (ViewModel) : Vue实例对象</p><p>VM负责的功能有:</p><ol><li> 数据绑定 :</li></ol><p>   将data中的数据 通过vue的特有形式 绑定到模板（前端页面）中</p><ol start="2"><li><p>DOM监听 : </p><p>例子：双向绑定 当页面数据发生改变时 data中的数据也发生对应改变</p></li></ol><h3 id="Vue中的数据代理"><a href="#Vue中的数据代理" class="headerlink" title="Vue中的数据代理"></a>Vue中的数据代理</h3><p>vm中data中的数据 全部为options.data的代理</p><p>Vue使用数据格式为name而不是为__data.name的原因是:</p><p>​    data获取到__data.name时候,往vm中添加了个name</p><p>​    然后通过原型中的getter读取_data中的name_</p><p>​    而修改就通过setter修改_data中的name_</p><h2 id="data中的数据劫持"><a href="#data中的数据劫持" class="headerlink" title="_data中的数据劫持"></a>_data中的数据劫持</h2><ol><li>创建一个新的Observer构造函数 将data中的全部属性都通过defineProperty添加到该对象中</li><li>vm._data = data = Observer实例对象</li></ol><p><strong>代码:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">let data = &#123;</span><br><span class="line">  name: &#x27;张三&#x27;,</span><br><span class="line">  age: 18</span><br><span class="line">&#125;</span><br><span class="line">//创建一个监视的实例对象,用于监视data中的属性变化</span><br><span class="line">const obs = new Observer(data);</span><br><span class="line"></span><br><span class="line">function Observer(data) &#123;</span><br><span class="line">  //1.汇总对象中的所有属性形成一个数组</span><br><span class="line">  const keys = Object.keys(data);</span><br><span class="line">  //遍历</span><br><span class="line">  keys.forEach((key) =&gt; &#123;</span><br><span class="line">    //this为obs</span><br><span class="line">    Object.defineProperty(this,key,&#123;</span><br><span class="line">      //给obs添加data的属性</span><br><span class="line">      get() &#123;</span><br><span class="line">        return data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      //当数据发生改变时候  改变将值赋值给data</span><br><span class="line">      set(v) &#123;</span><br><span class="line">        console.log(&#x27;$&#123;k&#125;被改了,我要去解析模板，生成虚拟DOM....&#x27;);</span><br><span class="line">        data[key] = v</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">  vm._data = data =obs</span><br><span class="line">  console.log(obs);</span><br></pre></td></tr></table></figure><h3 id="V-for中的key进行作用的流程"><a href="#V-for中的key进行作用的流程" class="headerlink" title="V-for中的key进行作用的流程"></a>V-for中的key进行作用的流程</h3><ol><li>将初始数据转化为虚拟DOM key就在虚拟dom中</li><li>将虚拟dom转为真实DOM</li><li>当初始数据发生改变时 根据新数据生成一个新的虚拟DOM</li><li>新的虚拟DOM与旧的虚拟DOM进行对比(通过diff算法) 相同的key进行内容的对比 如果内容不相同 则将对应新的DOM替换旧的DOM 生成新的真实DOM</li></ol><ul><li>注:对比时和你文本输入框的内容无关 只和你input的内容有关 因此key相同的虚拟DOM元素都会复用前者的输入框</li></ul><h4 id="Vue动态更新的问题"><a href="#Vue动态更新的问题" class="headerlink" title="Vue动态更新的问题"></a>Vue动态更新的问题</h4><h3 id="Vue-set的使用"><a href="#Vue-set的使用" class="headerlink" title="Vue.set的使用"></a>Vue.set的使用</h3><p><strong>对对象使用</strong></p><p>Vue.set(追加属性的对象,追加属性名,追加属性值 )</p><p>注: 只能给data中的对象添加属性 给data不能添加属性</p><p><strong>对数组使用</strong></p><p>Vue.set(将要替换元素的数组,索引值, 替换的值)</p><p>除官网给出的</p><h3 id="vuex工作原理"><a href="#vuex工作原理" class="headerlink" title="vuex工作原理"></a>vuex工作原理</h3>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven笔记</title>
      <link href="/2021/07/06/maven%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/06/maven%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>maven的主要功能</strong></p><ol><li>管理jar文件</li><li>自动下载jar和他的文档，源代码</li><li>管理jar直接的依赖 ，如：当a.jar需要b.jar时自动帮你下载b.jar</li><li>管理你需要的jar版本</li><li>帮你编译程序，把java编译成class</li><li>帮你测试你的代码是否正确</li><li>帮你打包文件，形成jar文件，或者war文件</li><li>帮你部署项目</li></ol><p><strong>构建：项目的构建</strong></p><p>构建时面向过程的，就是一些步骤，完成项目代码的编译、运行、打包、部署等。</p><p>maven支持的构建包括：</p><ol><li>清理：把之前编译的东西删除掉，为新的编译代码做准备。</li><li>编译：将源代码编译为执行代码，与javac的一次编译一个不同。</li><li>测试：maven可以执行测试程序代码，验证你的功能是否正确，并且可以执行多个测试代码，同时测试很多功能。</li><li>报告：生成测试结果的文件。</li><li>打包：把项目中的所有class文件，配置文件等所有资源放到一个压缩文件中。</li><li>安装：把5中生成的jar、war文件安装到本机仓库。</li><li>部署：把程序安装号可以执行。</li></ol><p><strong>maven核心概念</strong></p><ul><li><p>POM</p><ul><li><p>一个文件 名称是pom.xml,pom翻译过来叫做项目对象模型。</p><p>maven把一个项目当作一个模型来使用。控制maven构建项目的过程，管理jar依赖。</p></li></ul></li><li><p>约定的目录结构</p><ul><li>maven项目的目录和文件的位置都是规定的。</li></ul></li><li><p>坐标</p><ul><li>是一个唯一字符串，用来表示资源的。</li></ul></li><li><p>依赖管理</p><ul><li>管理你的项目可以使用jar文件。</li></ul></li><li><p>仓库管理</p><ul><li>资源存放的位置。</li></ul></li><li><p>生命周期</p><ul><li>maven构建项目的过程</li></ul></li><li><p>插件和目标</p><ul><li>执行maven构建时使用的工具是插件。</li></ul></li><li><p>继承</p></li><li><p>聚合</p></li></ul><p><strong>maven约定的目录结构</strong></p><p>hello</p><p>—/src</p><p>——/main #放你主程序java代码和配置文件</p><p>———/java #你的程序包和包中的java文件</p><p>———/resources #你的java程序中要使用的配置文件</p><p>——/test    #放测试程序代码和文件的</p><p>———/java #测试程序包和包中的java文件</p><p>———/resources #测试java程序中要使用的配置文件</p><p>—pom.xml</p><p><strong>POM</strong></p><p>第一次使用maven命令时需下载大量的jar包，下载的jar文件默认存放在：C:\Users\系统登陆的用户名\.m2\repository中</p><p>修改默认存储的位置：</p><ol><li>​    打开maven根目录下的conf文件夹，找到setting.xml</li><li>打开setting.xml找到：<code>&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</code></li><li>将标签内的路径修改为，你要存储的的位置，并将其移除注释</li><li>将斜杠改成反斜杠</li></ol><p><strong>坐标</strong>：唯一值 在互联网中唯一标识一个项目的</p><p><code>&lt;dependency&gt;</code><br>    <code>&lt;groupId&gt;com.hi&lt;/groupId&gt; #组织名</code><br>    <code>&lt;artifactId&gt;ch01-maven&lt;/artifactId&gt; #项目名字</code><br>    <code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  #项目版本号</code><br><code>&lt;/dependency&gt;</code></p><p><strong>命令</strong></p><ul><li>mvn clean</li><li>mvn compile：在项目根目录下生成target目录（结果目录）存放编译后的class文件<ul><li>会将main/java/目录下的java文件编译为class文件，同时把class拷贝到target/classes目录下</li><li>把main/resources目录下的所有文文件，都拷贝到target/classes目录下 </li></ul></li><li>mvn test-compile</li><li>mvn test</li><li>mvn package</li><li>mvn install</li><li>mvn deploy</li></ul><p><strong>仓库</strong></p><ul><li>仓库是什么：存放东西高的，存放maven使用的jar和我们项目使用的jar</li><li>仓库分类：<ul><li>本地仓库：个人计算机中的文件夹。</li><li>远程仓库：在互联网上的，使用网络才能使用的仓库。</li><li>中央仓库：最权威的，所有开发人员都能共享使用的一个集中的仓库。</li><li>中央仓库的镜像：中央仓库的备份，各大洲重要的地区都有一个 来分担中央仓库压力。</li><li>私服：在公司的内部，在局域网中使用，不是对外使用的。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话技术cookie和session</title>
      <link href="/2021/06/30/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFcookie%E5%92%8Csession/"/>
      <url>/2021/06/30/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFcookie%E5%92%8Csession/</url>
      
        <content type="html"><![CDATA[<h3 id="会话技术概念"><a href="#会话技术概念" class="headerlink" title="会话技术概念"></a>会话技术概念</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><ul><li>​    会话：一次会话中包含多次请求和响应。<ul><li>一次会话：浏览器第一次给服务器发送请求，会话建立，直到有一方断开（浏览器关闭或者服务器关闭）为止</li></ul></li><li>功能：在一次会话的范围内的多次请求间，共享数据</li><li>方式：<ul><li>客户端会话技术：Cookie</li><li>服务器端会话技术：Session</li></ul></li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>客户端会话技术，将数据保存到客户端</p><h4 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h4><ul><li>创建Cookie对象，绑定数据<ul><li>new Cookie(String name,String value)</li></ul></li><li>发送Cookie对象<ul><li>HttpServletResponse对象有个addCookie()方法</li></ul></li><li>接受Cookie对象<ul><li><ul><li>HttpServletRequest对象有个Cookie[] getCookies()方法获取Cookie数组</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>request和response入门</title>
      <link href="/2021/06/29/request%E5%92%8Cresponse%E5%85%A5%E9%97%A8/"/>
      <url>/2021/06/29/request%E5%92%8Cresponse%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="request和response对象的原理"><a href="#request和response对象的原理" class="headerlink" title="request和response对象的原理"></a><strong>request和response对象的原理</strong></h5><h4 id="request入门"><a href="#request入门" class="headerlink" title="request入门"></a>request入门</h4><ol><li>tomcat服务器会根据请求url中的资源路径，去创建对应的Servlet实现类对象。</li><li>tomcat服务器，会创建request和response对象，requset对象中封装请求消息数据。</li><li>tomcat将request和response两个对象传递给service方法，并调用service方法。</li><li>程序员，通过request对象获取请求消息数据，可以通过response对象设置响应消息数据。</li><li>服务器再给浏览器做出响应之前，会从response对象中拿程序员设置的的响应消息数据。</li></ol><h5 id="requset对象继承体系结构"><a href="#requset对象继承体系结构" class="headerlink" title="requset对象继承体系结构"></a><strong>requset对象继承体系结构</strong></h5><p>ServletRequset –接口</p><p>​            |    继承</p><p>HttpServletRequset –接口</p><p>​            |    实现</p><p>org.apache.catalina.connector.RequsetFacade类(由tomcat实现)</p><h5 id="request功能"><a href="#request功能" class="headerlink" title="request功能"></a><strong>request功能</strong></h5><ul><li>获取请求消息数据</li></ul><ol><li><p>​    获取请求行数据</p><ul><li>获取请求方式：GET<ul><li>String getMethod()</li></ul></li><li>获取虚拟目录：/day14<ul><li>String getContextPath()</li></ul></li><li>获取Servlet路径：/demo1<ul><li>String getServlePath()</li></ul></li><li>获取get方式请求参数：name=zhangsan<ul><li>getQueryString()</li></ul></li><li>获取请求的uri：/day14/demo1<ul><li>String getRequestURI()：统一资源标识符</li><li>StringBuffer getRequestURL()：ton</li></ul></li><li>获取协议及版本号：HTTP/1.1<ul><li>String getProtocol()</li></ul></li><li>获取客户机的ip地址（ip6）:<ul><li>String getRemoteAddr()</li></ul></li></ul></li><li><p>​    获取请求头数据</p><ul><li>方法：<ul><li>String getHeader(String name)：通过请求头的名称 获取请求头的值</li><li>getHearderNames()：获取所有的请求头名称</li></ul></li></ul></li><li><p>​    获取请求体数据</p><ol><li><p>请求体:只有POST请求中，才有请求体，在请求体中封装了POST请求的请求参数</p></li><li><p>步骤：</p><ol><li>获取流对象<ul><li>BufferedReader getReader()：获取字符输入流</li><li> ServletInputStream getInputStream()：获取字节输入流</li></ul></li></ol></li></ol></li><li><p>再从流当中获取数据</p></li></ol><h5 id="其它功能："><a href="#其它功能：" class="headerlink" title="其它功能："></a><strong>其它功能：</strong></h5><ol><li>获取请求参数通用方式<ul><li>String getParameter(String name)：根据参数名称获取参数值</li><li>String[] getParameterValues(String name)：根据参数名称获取参数值的数组</li><li>Enumeration&lt;String&gt; getParameterNames()：获取所有请求参数的名称</li><li>Map&lt;String,String[]&gt; getParameterMap()：获取所有参数键值对的map集合</li></ul></li><li>请求转发：一种在服务器内部的资源跳转方式<ul><li>步骤:<ul><li>通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)</li><li>使用forward(ServletRequest request,ServletResponse response)方法进行转发</li></ul></li><li>特点<ul><li>转发时浏览器地址路径不发生变化</li><li>只能转发到当前服务器的内部资源中</li><li>转发是一次请求</li></ul></li></ul></li><li>共享数据<ul><li>域对象：一个有作用范围的对象，可以在访问内共享数据</li><li>request域 ：代表一次请求的范围，一般用于请求转发的多个资源中共享数据<ul><li>方法:<ul><li>setAttribute(String name,Object obj)：存储数据</li><li>Object getAttribute(String name)：通过键获取数据</li><li>removeAttribute(String name)：通过键名移除键值对</li></ul></li></ul></li></ul></li><li>获取ServletContext<ul><li>ServletContext getServletContext()</li></ul></li></ol><h5 id="解决乱码问题"><a href="#解决乱码问题" class="headerlink" title="解决乱码问题"></a><strong>解决乱码问题</strong></h5><ul><li>get方式：tomcat 8 已经将get方式的乱码问题解决</li><li>post方式：会乱码<ul><li>解决：设置流的字符集：request.setCharacterEncoding(“utf-8”)</li></ul></li></ul><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h5><ul><li><p>BeanUtils的基本使用:</p><ul><li>获取请求参数Map集合</li><li>创建JavaBean实例对象</li><li>调用:BeanUtils.populate(Object bean,Map properties)</li></ul></li><li><p>JavaBean：标准的Java类</p><ul><li><p>要求:</p><ul><li>类必须被public修饰</li><li>必须提供空参的构造器</li><li>成员变量必须使用private修饰</li><li>提供公共的setter和getter方法</li></ul></li><li><p>功能：封装数据</p></li></ul></li><li><p>成员变量：</p></li><li><p>属性：setter和getter方法截取后的产物</p><ul><li>例如：getUsername() –&gt; Username –&gt; username</li></ul></li></ul><h4 id="response入门"><a href="#response入门" class="headerlink" title="response入门"></a>response入门</h4><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><ul><li>设置响应消息</li><li>设置响应行<ul><li>格式：HTTP/1.1       200    OK</li><li>设置状态码：setStatus(int sc)</li></ul></li><li>设置响应头：setHeader(String name,String value)</li><li>设置响应体：<ul><li>使用步骤：</li><li>获取输出流<ul><li>字符输出流：printWriter getWriter()</li><li>字节输出流：ServletOutputStream getOutputStream()</li></ul></li><li>使用输出流,将数据输出到客户端浏览器</li></ul></li></ul><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向:"></a>重定向:</h5><p><strong>实现:</strong></p><ol><li><p>设置状态码为302</p></li><li><p>设置响应头location</p><p><strong>简单的重定向方法：sendRedirect(“资源路径”)</strong></p></li></ol><p><strong>转发与重定向的区别</strong></p><ul><li><p>重定向的特点：redirect</p><ul><li>地址栏发生变化</li><li>重定向可以访问其他站点（服务器）的资源</li><li>重定向是两次请求。不能使用request共享数据</li></ul></li><li><p>转发的特点：forward</p><ul><li>转发地址栏路径不变</li><li>转发只能访问当前服务器下的资源</li><li>转发是一次请求</li></ul></li></ul><h5 id="路径写法"><a href="#路径写法" class="headerlink" title="路径写法"></a><strong>路径写法</strong></h5><ul><li>相对路径：通过相对路径不可以确定唯一资源<ul><li>不以/开头，以.开头的路径</li><li>规则：找到当前资源与目标资源之间的相对位置关系<ul><li>./：当前目录</li><li>../：后退一级目录</li></ul></li></ul></li><li>绝对路径：通过绝对路径可以确定唯一资源<ul><li>以/开头的路径</li><li>规则：判断定义的路径是给谁用的？判断请求从拿发出<ul><li>给客户端浏览器使用：需加虚拟目录</li><li>给服务器使用（转发）：不需要加虚拟目录</li></ul></li></ul></li></ul><h5 id="输出字符数据出现乱码问题"><a href="#输出字符数据出现乱码问题" class="headerlink" title="输出字符数据出现乱码问题"></a>输出字符数据出现乱码问题</h5><p>**原因:**浏览器解码的编码与tomcat获取流对象的编码不相同</p><p><strong>解决:</strong></p><ul><li><p>使用setCharacterEncoding()将流对象的编码设置成与浏览器相同</p><p>但此方法有局限性，因为浏览器编码会随着系统环境变化而变化</p></li><li><p>使用setHeader(“content-type”,”text/html;charset=utf-8”)</p><p>告诉浏览器使用utf-8解码,来解决上述问题（设置了此项可以不用设置第一项）</p></li><li><p>使用setContentType()是上述方法的简写形式</p></li></ul><h5 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h5><ul><li><p>概念：代表整个web应用，可以和程序的容器（服务器）来通信</p></li><li><p>获取：</p><ul><li>通过request对象获取<ul><li>request.getServletContext()</li></ul></li><li>通过HttpServlet获取<ul><li>this.getServletContext()</li></ul></li></ul></li><li><p>功能：</p><ul><li><p>获取MIME类型</p><ul><li>MIME类型：在网络通信过程中定义的一种文件数据类型<ul><li>格式：大类型/小类型    text/html    image/jpg</li></ul></li><li>获取：String getMimeType(String file)</li></ul></li><li><p>域对象：共享数据</p><ul><li>setAttribute(String name,Object obj)：存储数据</li><li>Object getAttribute(String name)：通过键获取数据</li><li>removeAttribute(String name)：通过键名移除键值对</li></ul><p><strong>ServletContext对象范围：所有用户所有请求的数据</strong></p></li><li><p>获取文件的真实（服务器）路径</p><ul><li>方法：String getRealPath(String path)</li></ul></li></ul></li></ul><h5 id="文件下载案例"><a href="#文件下载案例" class="headerlink" title="文件下载案例"></a><strong>文件下载案例</strong></h5><ul><li><p>分析：</p><ul><li>超链接指向的资源如果能被浏览器解析，则在浏览器中显示，如果不能解析，则弹出下载提示框</li><li>任何资源都必须弹出下载提示框</li><li>使用响应头设置资源的打开方式：<ul><li>Content-disposition:attachment;filename=xxx</li></ul></li></ul></li><li><p>步骤</p><ul><li>定义页面，编辑超链接href属性，指向Servlet同时将请求的资源名称传递过去</li><li>定义Servlet <ul><li>获取文件名称</li><li>将文件使用字节输出流加载到内存中</li><li>设置指定response的响应头：<ul><li>Content-disposition:attachment;filename=xxx（ps:filename为下载时的文件名）</li><li>content-type</li></ul></li><li>将数据写出到response输出流</li></ul></li></ul></li><li><p>注意事项:设置中文下载名会出现乱码事件 因此需解决</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP入门学习</title>
      <link href="/2021/06/28/HTTP%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/28/HTTP%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="概念：Hypertext-Transfer-Protocol超文本传输协议"><a href="#概念：Hypertext-Transfer-Protocol超文本传输协议" class="headerlink" title="概念：Hypertext Transfer Protocol超文本传输协议"></a>概念：Hypertext Transfer Protocol超文本传输协议</h4><h5 id="传输协议："><a href="#传输协议：" class="headerlink" title="传输协议："></a><strong>传输协议</strong>：</h5><ul><li>定义了，客户端和服务器通信时，发送数据的格式</li></ul><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点</strong>：</h5><ul><li>基于TCP/IP的高级协议</li><li>默认端口号：80</li><li>基于请求/响应模型的：一次请求对应一次响应</li><li>无状态的：每次请求相互独立，不能交互数据</li></ul><h5 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本:"></a><strong>历史版本</strong>:</h5><ul><li>1.0：每一次请求响应都会建立新的连接</li><li>1.1：复用连接（等待一段时间看看是否还有请求）</li></ul><h5 id="请求消息数据格式："><a href="#请求消息数据格式：" class="headerlink" title="请求消息数据格式："></a><strong>请求消息数据格式</strong>：</h5><ul><li><p>请求行</p><p>请求方式  请求的url       请求协议/版本</p><p>GET           /index.html   HTTP/1.1</p></li><li><p>请求头</p><p>请求头名称 : 请求头值</p></li><li><p>请求空行</p><p>空行</p></li><li><p>请求体</p><p>POST请求中可以获取到</p><p>username=zhangshan</p></li></ul><h5 id="请求方式："><a href="#请求方式：" class="headerlink" title="请求方式："></a><strong>请求方式</strong>：</h5><p>HTTP协议中有7种请求方式，常用的有两种</p><ul><li>GET: </li></ul><p>​            请求参数在请求行中，在url后。</p><p>​            请求的url长度有限制的（POST没有限制）</p><p>​            不太安全</p><ul><li>POST:</li></ul><p>​            请求参数在请求体中</p><p>​            相对安全</p><h5 id="常见的请求头"><a href="#常见的请求头" class="headerlink" title="常见的请求头"></a><strong>常见的请求头</strong></h5><ul><li><p>User-Agent：浏览器告诉服务器，访问使用的浏览器版本信息</p><p>可以在浏览器获取该头的信息，来解决不同浏览器的兼容问题</p></li><li><p>Referer：告诉服务器，请求从哪来</p><p>作用：</p><p>​        1.防盗链</p><p>​        2.统计工作</p></li></ul><h5 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h5><ul><li><p>响应行</p><ul><li><p>组成：协议/版本 响应状态码 状态码描述</p><p>​            HTTP/1.1         200            OK</p></li><li><p>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。</p><ul><li>状态码都是3位数<ul><li>分类：<ul><li>1xx：服务器接受客户端消息，但没有接受完成，等待一段时间后，发送1xx状态码。</li><li>2xx：成功。</li><li>3xx：重定向。代表：302（重定向），304（访问缓存）。</li><li>4xx：客户端错误。</li><li>5xx：服务器端错误。</li></ul></li></ul></li></ul></li></ul></li><li><p>响应头</p><ul><li>常见响应头</li><li>Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式</li><li>Content-disposition：服务器告诉客户端以什么格式打开响应数据<ul><li>值：</li><li>in-line：默认值，在当前页面打开</li><li>attachment：以附件形式打开响应体。文件下载</li></ul></li></ul></li><li><p>响应空行</p></li><li><p>响应体：传输的数据</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servelt入门学习</title>
      <link href="/2021/06/28/Servelt%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/28/Servelt%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="概念：Server-Apple-服务器小程序"><a href="#概念：Server-Apple-服务器小程序" class="headerlink" title="概念：Server Apple 服务器小程序"></a>概念：Server Apple 服务器小程序</h4><ul><li>运行在服务器端的小程序</li><li>Servlet就是一个接口，定义了Java类被浏览器访问到（tomcat识别）的规则</li></ul><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ol><li><p>创建JavaEE项目</p></li><li><p>定义一个类实现Servlet接口，并且实现接口中的抽象方法</p></li><li><p>在web.xml中配置servlet，格式入下：</p><p><code>&lt;servlet&gt;</code></p><p><code>&lt;servlet-name&gt;name&lt;/servlet-name&gt;</code></p><p><code>&lt;servlet-class&gt;实现Servlet接口类的**全类名**&lt;/servlet-class&gt;</code></p><p><code>&lt;/servlet&gt;</code></p><p><code>&lt;servlet-mapping&gt;</code></p><p><code>&lt;servlet-name&gt;name&lt;/servlet-name&gt;</code></p><p><code>&lt;url-pattern&gt;在浏览器访问资源的路径&lt;/url-pattern&gt;</code></p><p><code>&lt;/servlet-mapping&gt;</code></p></li></ol><h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4><ol><li>当服务器接受到客户端浏览器的请求后，会解析url的请求路径（找tomcat 找tomcat部署的项目），获取访问的Servlet的资源路径</li><li>查找web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容 。</li><li>如果有则通过<code>&lt;servlet-name&gt;</code>标签体的内容，找到&lt;servlet&gt;标签中的<code>&lt;servlet-class&gt;</code>标签中的全类名</li><li>tomcat将字节码文件加载进内存 再创建其对象</li><li>调用其方法</li></ol><h4 id="Servlet方法"><a href="#Servlet方法" class="headerlink" title="Servlet方法"></a>Servlet方法</h4><p><strong>生命周期方法：</strong></p><ul><li><p>public void init(ServletConfig servletConfig)：初始化方法在Servlet被创建时调用</p><p><strong>Servlet的init方法只执行一次 ，说明Servlet在内存中只存在一个对象，Servlet是单例的</strong></p><p><strong>当多个用户进行访问同一个对象时，可能存在线程安全问题</strong></p><p><strong>解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量也不要修改其值</strong></p></li><li><p>public void service(ServletRequest servletRequest, ServletResponse servletResponse)：提供服务的方法 每次Servlet被访问时执行</p></li><li><p>public void destroy()：服务器正常关闭时执行</p></li></ul><p>其他方法：</p><ul><li>public ServletConfig getServletConfig()：获取Servlet配置对象的方法(通过配置对象对Servlet进行操作)</li><li>public String getServletInfo()：获取Servlet信息的方法（版本、作者等）</li></ul><h4 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h4><p><strong>Servlet在什么时候被创建？</strong></p><ul><li>默认情况下，第一次访问时，Servlet被创建</li><li>可以配置<code>&lt;load-on-startup&gt;</code>标签来实现不同时候创建</li><li>当值为正数或0时:在服务器启动时创建</li><li>当值为负数时：第一次被访问时创建</li></ul><h4 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h4><p><strong>好处：</strong></p><p>支持注解配置。可以不需要web.xml了</p><p><strong>使用：</strong></p><p>给实现了Servlet的类添加注解：@WebServlet(“资源路径”)</p><h4 id="Servlet体系"><a href="#Servlet体系" class="headerlink" title="Servlet体系"></a>Servlet体系</h4><p>Servlet –接口</p><p>​    |</p><p>genericServlet –抽象类(只将service方法抽象 其他方法都中实现了)</p><p>​    |</p><p>HttpServlet –抽象类</p><p><strong>HttpServlet在service方法中干了下面这件事:</strong></p><p><code>//判断请求方式</code><br><code>String method=req.getMethod();</code><br><code>if (&quot;GET&quot;.equals(method))&#123;</code><br>    <code>//get方式获取数据</code></p><p>​    <code>    doGet()</code></p><p><code>&#125;else if (&quot;POST&quot;.equals(method))&#123;</code><br>    <code>//post方式请求数据</code></p><p>​    <code>doPost()</code></p><p><code>&#125;</code></p><p>因此继承HttpServlet只用实现doGet()和doPost()方法</p><p><strong>url-pattern</strong></p><ol><li>Servlet的资源路径可以配置多个</li><li>路径定义规则:</li></ol><p>​                /xxx</p><p>​                /xxx/xxx：多层路径，目录结构</p><p>​                *.do</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程中遇到的一些小问题</title>
      <link href="/2021/06/28/%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2021/06/28/%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>时间</th><th>问题</th><th>解决方案</th></tr></thead><tbody><tr><td>2021/6/28</td><td>使用Ajax请求时，Servlet无法进行重定向</td><td>通过location.href来实现重定向的要求，地址值可以在js中定义也可以通过后台传递给前台</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript笔记</title>
      <link href="/2021/06/22/javaScript%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/06/22/javaScript%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><h4 id="基本-值-类型"><a href="#基本-值-类型" class="headerlink" title="基本(值)类型"></a>基本(值)类型</h4><ul><li><p>String：任意字符串</p></li><li><p>Number：任意数字</p></li><li><p>boolean：true/false</p></li><li><p>undefined：undefined</p></li><li><p>null：null</p></li></ul><h4 id="对象-引用-类型"><a href="#对象-引用-类型" class="headerlink" title="对象(引用)类型"></a>对象(引用)类型</h4><ul><li><p>Object：任意对象</p></li><li><p>Function：一种特别的对象（可以执行）</p></li><li><p>Array：一种特别的对象（数值下标，内部数据是有序的）</p></li><li><p>类型也为一个对象（类型对象） 根据类型创建的对象叫实例对象</p></li></ul><h4 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h4><h5 id="typeof："><a href="#typeof：" class="headerlink" title="typeof："></a><strong>typeof：</strong></h5><ul><li><p>​    判断返回值为字符串，因此使用为:typeof a===’undefined’</p></li><li><p>​    可以判断:undefined、数值、布尔值、字符串</p></li><li><p>​    不能判断:Object与null（typeof null值 返回的字符串为Object） Object与Array（typeof Array对象 返回值为Object）</p></li></ul><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof:"></a><strong>instanceof:</strong></h5><ul><li>​    判断对象（具体）的类型</li></ul><h5 id><a href="#" class="headerlink" title="===:"></a><strong>===:</strong></h5><ul><li><p>​    可以判断:undefined、null（判断的为值与类型是否相等,且默认undefined===null）</p></li><li><p>​    ps:==进行数字与字符串比较时，会将字符串转化为数字再进行比较</p></li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h4><h5 id="undefined和null的区别"><a href="#undefined和null的区别" class="headerlink" title="undefined和null的区别:"></a>undefined和null的区别:</h5><ul><li>undefined代表定义未赋值</li><li>null代表定义且赋了值 但值为null</li></ul><h5 id="什么时候使用null"><a href="#什么时候使用null" class="headerlink" title="什么时候使用null:"></a>什么时候使用null:</h5><ul><li>初始赋值时:表明该变量为一个对象时,可以使用null初始赋值占位</li><li>结束前:让变量成为垃圾对象（被回收）</li></ul><h5 id="严格区分变量类型和数据类型："><a href="#严格区分变量类型和数据类型：" class="headerlink" title="严格区分变量类型和数据类型："></a>严格区分变量类型和数据类型：</h5><p>数据的类型</p><ul><li>基本类型：保存的就是基本类型、数据</li><li>对象类型</li></ul><p>变量的类型（变量内存值的类型）</p><ul><li>基本类型：保存的就是基本类型、数据</li><li>引用类型：保存的为地址值（变量对堆内存中对象地址值的引用）</li></ul><h3 id="2-内存"><a href="#2-内存" class="headerlink" title="2.内存"></a>2.内存</h3><h4 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a><strong>什么是数据？</strong></h4><ul><li>存储在内存中代表特点信息的二进制</li><li>具有可读写可传递的基本特性</li><li>程序中所有操作的目标都是数据</li></ul><h4 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a><strong>什么是内存？</strong></h4><ul><li><p>内存是内存条通电后产生可存储数据的空间（临时的）</p></li><li><p>每一块小内存存储着两个数据（内部存储的数据、地址值数据）</p></li><li><p>栈：存储全局变量、局部变量</p></li><li><p>堆：存储对象（函数名为一个变量名在栈空间中）</p></li></ul><h4 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a><strong>什么是变量？</strong></h4><ul><li><p>可变化的量，由变量名和变量值组成</p></li><li><p>每个可变的量都在内存区占着一快小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据</p></li></ul><h4 id="内存、数据、变量三者之间的关系"><a href="#内存、数据、变量三者之间的关系" class="headerlink" title="内存、数据、变量三者之间的关系"></a><strong>内存、数据、变量三者之间的关系</strong></h4><ul><li><p>内存是用来存储数据的临时空间（相比硬盘读写快）</p></li><li><p>变量是内存的标识（目的就是对内存中的数据进行操作:读、写）</p></li></ul><h4 id="关于引用变量的一些问题"><a href="#关于引用变量的一些问题" class="headerlink" title="关于引用变量的一些问题"></a><strong>关于引用变量的一些问题</strong></h4><h5 id="1-两个引用变量指向同一对象"><a href="#1-两个引用变量指向同一对象" class="headerlink" title="1.两个引用变量指向同一对象"></a><strong>1.两个引用变量指向同一对象</strong></h5><p><code>var a=&#123;name:&quot;Tom&quot;&#125;;</code><br><code>var b=a;</code><br><code>console.log(b.name);//Tom</code><br><code>function fn(obj)&#123;</code><br>    <code>obj.name=&quot;Bob&quot;</code><br><code>&#125;</code><br><code>fn(a)</code><br><code>console.log(b.name);//Bob</code></p><p><strong>原因：</strong></p><ul><li><p>var b=a时只是将a的<strong>内存内容（只不过内存内容为一个地址值）</strong>保存到b中</p></li><li><p>而fn(a)只是将a做为<strong>实参</strong>赋值给obj对象（当然赋的值也是内存内容）</p></li><li><p>因此<strong>三个变量引用的都为同一个对象的地址值进行操作</strong></p></li></ul><hr><h5 id="2-两个引用变量指向不同对象"><a href="#2-两个引用变量指向不同对象" class="headerlink" title="2.两个引用变量指向不同对象"></a><strong>2.两个引用变量指向不同对象</strong></h5><p><code>var a=&#123;age:12&#125;</code><br><code>var b=a;</code><br><code>var a=&#123;name:&quot;Bob&quot;,age:14&#125;</code><br><code>console.log(b.age,a.age)//12 14</code><br><code>function fn(obj) &#123;</code><br>    <code>obj=&#123;age:15&#125;</code><br><code>&#125;</code><br><code>fn(a)</code><br><code>console.log(a.age)//14</code></p><p><strong>原因:</strong></p><ul><li><p><strong>当对象引用发生改变时 被引用对象和引用对象不是同一个对象</strong></p></li><li><p>fn<strong>函数</strong>执行完后内部的局部变量就会<strong>自动释放</strong>，一旦自动释放之后</p></li><li><p>obj对象就会成为垃圾对象，<strong>因此调用a时调用的是变量值为 {name:”Bob”,age:14} 的对象</strong></p></li><li><p>(说白了就是obj和a存储的不是同一个对象地址值 因此obj影响不了a)</p></li><li><p><strong>3.在js调用函数时传递变量参数时，是值传递还是引用传递？</strong></p></li><li><p>答：可能是值传递也可能是，引用传递（地址值）,取决于参数是否为对象</p></li></ul><h4 id="JS引擎管理内存的方式"><a href="#JS引擎管理内存的方式" class="headerlink" title="JS引擎管理内存的方式"></a>JS引擎管理内存的方式</h4><h5 id="1-内存生命周期"><a href="#1-内存生命周期" class="headerlink" title="1.内存生命周期"></a><strong>1.内存生命周期</strong></h5><ul><li>分配小内存空间，得到它的使用权</li><li>存储数据，可以反复进行操作</li><li>释放小内存空间</li></ul><h5 id="2-释放内存"><a href="#2-释放内存" class="headerlink" title="2.释放内存"></a><strong>2.释放内存</strong></h5><ul><li>局部变量:函数执行完自动释放</li><li>对象:成为垃圾对象–&gt;垃圾回收器回收</li></ul><h3 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h3><h4 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a><strong>什么是对象？</strong></h4><ul><li>多个数据的封装体（集合体）</li><li>用来保存多个数据的容器</li><li>一个对象代表现实中的一个事物，是该事物在编程中的抽象</li></ul><h4 id="为什么要用对象？"><a href="#为什么要用对象？" class="headerlink" title="为什么要用对象？"></a><strong>为什么要用对象？</strong></h4><ul><li>统一管理多个数据</li></ul><h4 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a><strong>对象的组成</strong></h4><ul><li><strong>属性：</strong></li><li>由属性名（字符串）和属性值（任意类型）组成</li><li>代表现实事物的状态数据</li><li><strong>方法：</strong></li><li>一种特殊的属性（属性值是方法）</li><li>代表事物的行为</li></ul><h4 id="如何访问对象内部数据"><a href="#如何访问对象内部数据" class="headerlink" title="如何访问对象内部数据"></a><strong>如何访问对象内部数据</strong></h4><ul><li><p>.属性名：编码简单，有时不能用</p></li><li><p>[‘属性名’]：编码麻烦，能通用</p><p>​    <strong>使用场景:</strong></p><p>​        1.当属性名包含特殊符号：- 空格时可以使用，而上者不行</p><p>​        2.当变量名不确定时,如:</p><p>​                                <code>var p=&#123;name:&#39;yanghan&#39;&#125;;</code></p><p>​                                <code>var c=&#39;name&#39;;</code></p><p>​                                <code>p.c;//无法获取p的属性yanghan,同时输出的为undefined</code></p><p>​                                <code>p[c];//能获取p的属性yanghan</code></p></li></ul><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h3><h4 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a><strong>什么是函数？</strong></h4><ul><li>实现特定功能的n条语句的封装体</li><li>只有函数是能执行的，其他类型的数据都不能执行</li></ul><h4 id="为什么要使用函数？"><a href="#为什么要使用函数？" class="headerlink" title="为什么要使用函数？"></a><strong>为什么要使用函数？</strong></h4><ul><li>提高代码复用</li><li>便于阅读交流（封装思想）</li></ul><h4 id="如何定义函数？"><a href="#如何定义函数？" class="headerlink" title="如何定义函数？"></a><strong>如何定义函数？</strong></h4><ul><li>函数声明：function xx(){}</li><li>表达式:var xx=function(){}</li></ul><h4 id="如何执行函数？"><a href="#如何执行函数？" class="headerlink" title="如何执行函数？"></a><strong>如何执行函数？</strong></h4><ul><li>test()：直接调用</li><li>obj.test()：通过对象调用</li><li>new test():new调用</li><li>test.call/apply(obj):让函数成为指定对象的方法进行调用</li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><h5 id="什么函数才是回调函数？"><a href="#什么函数才是回调函数？" class="headerlink" title="什么函数才是回调函数？"></a><strong>什么函数才是回调函数？</strong></h5><ul><li>自身定义的函数</li><li>你没调用该函数，但该函数自动执行了</li></ul><h5 id="常见的回调函数"><a href="#常见的回调函数" class="headerlink" title="常见的回调函数"></a><strong>常见的回调函数</strong></h5><ul><li>dom对象回调函数</li><li>定时器回调函数（定时器:循环定时器、一次性定时器）</li><li>ajax请求回调函数</li><li>生命周期回调函数</li></ul><h4 id="IIFE（立即执行调用函数表达式）"><a href="#IIFE（立即执行调用函数表达式）" class="headerlink" title="IIFE（立即执行调用函数表达式）"></a><strong>IIFE（立即执行调用函数表达式）</strong></h4><p>匿名函数自调用</p><p><code>( function()&#123;</code><br>    <code>var a=3;</code><br>    <code>console.log(a+3)</code><br><code>&#125;)()</code></p><p>作用:</p><p>​    实现隐藏</p><p>​    不会污染外部（全局）命名空间</p><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p><strong>什么是this?</strong></p><ul><li>任何函数本质都是通过某个对象来调用的，如果没指定就是window对象调用</li><li>所有函数内部都有一个变量this</li><li>它的值是调用函数的当前对象</li></ul><p><strong>如何确定this值?</strong></p><ul><li>test()：window</li><li>p.test()：p</li><li>new test()：创建对象</li><li>p.call(obj):obj</li></ul><hr><h1 id="函数高级"><a href="#函数高级" class="headerlink" title="函数高级"></a>函数高级</h1><h3 id="1-原型与原型链"><a href="#1-原型与原型链" class="headerlink" title="1.原型与原型链"></a>1.原型与原型链</h3><h4 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h4><p><strong>函数的prototype属性</strong></p><ul><li>每个函数都有prototype属性，它默认指向一个Object空对象(又称原型对象)</li><li>原型对象中又一个属性constructor，它指向函数对象</li></ul><p><strong>给原型对象添加方法</strong></p><ul><li>作用：函数的所有实例对象自动拥有原型中的属性(方法)</li></ul><h4 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h4><p><code>function Fn() &#123;//内部语句this.prototype=&#123;&#125;</code><br><code>&#125;</code><br><code>var fn = new Fn();//内部语句:fn.__proto__=Fn.prototype</code></p><ul><li>每个函数都一个prototype，即显式原型（属性）</li></ul><p><code>alert(Fn.prototype)</code></p><ul><li>每个实例对象都有一个__proto__，可称为隐式原型（属性）</li><li>对象隐式原型的值为其对应构造函数的显式原型的值</li></ul><p><code>alert(fn.__proto__)</code></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>访问一个对象的属性时</p><p>先在自身属性中查找查找，找到返回</p><p>如果没有再沿着__proto__这条链往上找，找到返回</p><p>如果最终没找到，返回undefined</p><p>别名：隐式原型链</p><p>作用：查找对象的属性（方法）</p><p><strong>补充</strong></p><p>函数的显式原型指向的对象默认是空Object实例对象(但Object不满足)</p><p>所有函数都是Function的实例(包括Function对象)</p><p>Object原型对象是原型链的尽头（原型对象的__proto__为null因此无法再进行查找）</p><h3 id="2-执行上下文与执行上下文栈"><a href="#2-执行上下文与执行上下文栈" class="headerlink" title="2.执行上下文与执行上下文栈"></a>2.执行上下文与执行上下文栈</h3><h3 id="3-作用域和作用链域"><a href="#3-作用域和作用链域" class="headerlink" title="3.作用域和作用链域"></a>3.作用域和作用链域</h3><h3 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的后端学习路线</title>
      <link href="/2021/06/16/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2021/06/16/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h4 id="第一阶段：Java基础知识-培养编程思维"><a href="#第一阶段：Java基础知识-培养编程思维" class="headerlink" title="第一阶段：Java基础知识(培养编程思维)"></a><strong>第一阶段：Java基础知识(培养编程思维)</strong></h4><blockquote><p>变量、数据类型、运算符</p><p>控制语句(循环嵌套多思考)</p><p>面向对象编程(转折点!作为初学者这块可能会很难!)</p><p>异常机制</p><p>Java常用类(API)</p><p>集合(代替数组 后期常用到)</p><p>iO流</p><p>多线程</p><p>网络编程</p></blockquote><h4 id="第二阶段：数据库阶段-后期都要连库操作"><a href="#第二阶段：数据库阶段-后期都要连库操作" class="headerlink" title="第二阶段：数据库阶段(后期都要连库操作)"></a><strong>第二阶段：数据库阶段(后期都要连库操作)</strong></h4><blockquote><p>MysSQL入门</p><p>DML（数据库操作语言）</p><p>DCL（数据库控制语言）</p><p>DDL（数据库定义语言）</p><p>单表查询</p><p>多表查询-内连接查询</p><p>多表查询-外连接查询</p><p>多表查询-子查询</p><p>视图</p><p>事务</p><p>索引</p><p>三大范式</p><p>存储过程</p></blockquote><h4 id="第三阶段：JDBC和GUi（学习MVC设计模式）"><a href="#第三阶段：JDBC和GUi（学习MVC设计模式）" class="headerlink" title="第三阶段：JDBC和GUi（学习MVC设计模式）"></a><strong>第三阶段：JDBC和GUi（学习MVC设计模式）</strong></h4><blockquote><p>GUI</p><p>JDBC及案例</p><p>使用properties读取属性文件</p><p>JDBC+GUI实现简易的程序（重点）</p></blockquote><h4 id="第四阶段：WEB前端-后端也需学一些前端知识-但没必要太过精通"><a href="#第四阶段：WEB前端-后端也需学一些前端知识-但没必要太过精通" class="headerlink" title="第四阶段：WEB前端(后端也需学一些前端知识 但没必要太过精通)"></a><strong>第四阶段：WEB前端(后端也需学一些前端知识 但没必要太过精通)</strong></h4><blockquote><p>HTML5</p><p>CSS3</p><p>JavaScript(可以选择精学)</p></blockquote><h4 id="第五阶段：JavaWeb"><a href="#第五阶段：JavaWeb" class="headerlink" title="第五阶段：JavaWeb"></a><strong>第五阶段：JavaWeb</strong></h4><blockquote><p>Tomcat与HTTF</p><p>Servlet(JavaWeb三大组件之一 spring框架底层技术需精学)</p><p>文件下载练习</p><p>JSP基础语法</p><p>EL</p><p>JSTL</p><p>Cookie</p><p>Session</p><p>Filter(JavaWeb三大组件之一)</p><p>listener(avaWeb三大组件之一)</p><p>MVC架构</p><p>JSON</p><p>Ajax</p><p>项目实战</p></blockquote><h4 id="第六阶段：框架"><a href="#第六阶段：框架" class="headerlink" title="第六阶段：框架"></a><strong>第六阶段：框架</strong></h4><blockquote><p>jquery(JavaScript的框架)</p><p>vue(JavaScript的框架)</p><p>SSM(常见的三大框架)</p></blockquote><p><strong>以上为个除了框架未学，其他均为个人大一所学的知识 知识全部从网上视频、书籍中所获取</strong></p><p><strong>能获取的资源有限，可能上述有些旧知识，请选择性参考!</strong></p><h6 id="可能此次总结不到位，此文章将持续更新"><a href="#可能此次总结不到位，此文章将持续更新" class="headerlink" title="可能此次总结不到位，此文章将持续更新!"></a><strong>可能此次总结不到位，此文章将持续更新!</strong></h6>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA的安装和开发工具的选择</title>
      <link href="/2021/06/16/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/"/>
      <url>/2021/06/16/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h4 id="JDK的安装"><a href="#JDK的安装" class="headerlink" title="JDK的安装"></a>JDK的安装</h4><p><strong>首先JDK的下载:</strong></p><p>去官网下载相应的JDK版本，这边推荐下载<strong>JDK的解压版</strong> 下载完配置完环境即可用，</p><p>不需要时删除即可,如果需要更改版本直接修改配置环境即可。</p><p>现在市面上用的最多的jdk版本为jdk8,因此下载推荐下载jdk8或者之上的版本</p><p><strong>环境变量的配置:</strong></p><p>1.此电脑→属性→高级系统设置→高级</p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img1.png"></p><p><img src="/image/img2.png"></p><p>2.选择环境变量→新建一个系统变量</p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img3-1624098983658.png"></p><p>变量名为<strong>JAVA_HOME</strong>  变量值为<strong>JAVA的绝对路径</strong></p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img4-1624098999268.png"></p><p>3.双击path→新建一个环境变量</p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img5.png"></p><p>4.给path添加一个新的环境变量名为:<strong>%JAVA_HOME%\bin</strong></p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img6.png"></p><p><u>ps:如果电脑不支持双击进入编辑界面 可以直接在path的值中添加：%JAVA_HOME%\bin;</u></p><h4 id="开发工具的选择"><a href="#开发工具的选择" class="headerlink" title="开发工具的选择"></a>开发工具的选择</h4><p>这里强烈不推荐eclipse!时代在前进而不是倒退,既然有比eclipse更强的<strong>idea</strong></p><p>为什么不用呢？所以推荐使用<strong>idea idea</strong>有着更方便的快捷键 有着更人性化的</p><p>设置。但完整版需付费 因此需动动小手破解一下</p><p>链接：<a href="https://pan.baidu.com/s/1HkUheAc21iyidsc5yGTkTA">https://pan.baidu.com/s/1HkUheAc21iyidsc5yGTkTA</a><br>提取码：lcbn </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
