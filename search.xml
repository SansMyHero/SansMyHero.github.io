<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>javaScript笔记</title>
      <link href="/2021/06/22/javaScript%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/06/22/javaScript%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><h4 id="基本-值-类型"><a href="#基本-值-类型" class="headerlink" title="基本(值)类型"></a>基本(值)类型</h4><ul><li><p>String：任意字符串</p></li><li><p>Number：任意数字</p></li><li><p>boolean：true/false</p></li><li><p>undefined：undefined</p></li><li><p>null：null</p></li></ul><h4 id="对象-引用-类型"><a href="#对象-引用-类型" class="headerlink" title="对象(引用)类型"></a>对象(引用)类型</h4><ul><li><p>Object：任意对象</p></li><li><p>Function：一种特别的对象（可以执行）</p></li><li><p>Array：一种特别的对象（数值下标，内部数据是有序的）</p></li><li><p>类型也为一个对象（类型对象） 根据类型创建的对象叫实例对象</p></li></ul><h4 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h4><h5 id="typeof："><a href="#typeof：" class="headerlink" title="typeof："></a><strong>typeof：</strong></h5><ul><li><p>​    判断返回值为字符串，因此使用为:typeof a===’undefined’</p></li><li><p>​    可以判断:undefined、数值、布尔值、字符串</p></li><li><p>​    不能判断:Object与null（typeof null值 返回的字符串为Object Object与Array（typeof Array对象 返回值为Object）</p></li></ul><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof:"></a><strong>instanceof:</strong></h5><ul><li>​    判断对象（具体）的类型</li></ul><h5 id><a href="#" class="headerlink" title="===:"></a><strong>===:</strong></h5><ul><li><p>​    可以判断:undefined、null（判断的为值与类型是否相等,且默认undefined===null）</p></li><li><p>​    ps:==进行数字与字符串比较时，会将字符串转化为数字再进行比较</p></li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h4><h5 id="undefined和null的区别"><a href="#undefined和null的区别" class="headerlink" title="undefined和null的区别:"></a>undefined和null的区别:</h5><ul><li>undefined代表定义未赋值</li><li>null代表定义且赋了值 但值为null</li></ul><h5 id="什么时候使用null"><a href="#什么时候使用null" class="headerlink" title="什么时候使用null:"></a>什么时候使用null:</h5><ul><li>初始赋值时:表明该变量为一个对象时,可以使用null初始赋值占位</li><li>结束前:让变量成为垃圾对象（被回收）</li></ul><h5 id="严格区分变量类型和数据类型："><a href="#严格区分变量类型和数据类型：" class="headerlink" title="严格区分变量类型和数据类型："></a>严格区分变量类型和数据类型：</h5><p>数据的类型</p><ul><li>基本类型：保存的就是基本类型、数据</li><li>对象类型</li></ul><p>变量的类型（变量内存值的类型）</p><ul><li>基本类型：保存的就是基本类型、数据</li><li>引用类型：保存的为地址值（变量对堆内存中对象地址值的引用）</li></ul><h3 id="2-内存"><a href="#2-内存" class="headerlink" title="2.内存"></a>2.内存</h3><h4 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a><strong>什么是数据？</strong></h4><ul><li>存储在内存中代表特点信息的二进制</li></ul><h4 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a><strong>什么是内存？</strong></h4><ul><li><p>内存是内存条通电后产生可存储数据的空间（临时的）</p></li><li><p>每一块小内存存储着两个数据（内部存储的数据、地址值数据）</p></li><li><p>栈：存储全局变量、局部变量</p></li><li><p>堆：存储对象（函数名为一个变量名在栈空间中）</p></li></ul><h4 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a><strong>什么是变量？</strong></h4><ul><li><p>可变化的量，由变量名和变量值组成</p></li><li><p>每个可变的量都在内存区占着一快小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据</p></li></ul><h4 id="内存、数据、变量三者之间的关系"><a href="#内存、数据、变量三者之间的关系" class="headerlink" title="内存、数据、变量三者之间的关系"></a><strong>内存、数据、变量三者之间的关系</strong></h4><ul><li><p>内存是用来存储数据的临时空间（相比硬盘读写快）</p></li><li><p>变量是内存的标识（目的就是查找内存中的数据）</p></li></ul><h4 id="关于引用变量的一些问题"><a href="#关于引用变量的一些问题" class="headerlink" title="关于引用变量的一些问题"></a><strong>关于引用变量的一些问题</strong></h4><h5 id="1-两个引用变量指向同一对象"><a href="#1-两个引用变量指向同一对象" class="headerlink" title="1.两个引用变量指向同一对象"></a><strong>1.两个引用变量指向同一对象</strong></h5><p><code>var a=&#123;name:&quot;Tom&quot;&#125;;</code><br><code>var b=a;</code><br><code>console.log(b.name);//Tom</code><br><code>function fn(obj)&#123;</code><br>    <code>obj.name=&quot;Bob&quot;</code><br><code>&#125;</code><br><code>fn(a)</code><br><code>console.log(b.name);//Bob</code></p><p><strong>原因：</strong></p><ul><li><p>var b=a时只是将a的<strong>内存内容（只不过内存内容为一个地址值）</strong>保存到b中</p></li><li><p>而fn(a)只是将a做为<strong>实参</strong>赋值给obj对象（当然赋的值也是内存内容）</p></li><li><p>因此<strong>三个变量引用的都为同一个对象的地址值进行操作</strong></p></li></ul><hr><h5 id="2-两个引用变量指向不同对象"><a href="#2-两个引用变量指向不同对象" class="headerlink" title="2.两个引用变量指向不同对象"></a><strong>2.两个引用变量指向不同对象</strong></h5><p><code>var a=&#123;age:12&#125;</code><br><code>var b=a;</code><br><code>var a=&#123;name:&quot;Bob&quot;,age:14&#125;</code><br><code>console.log(b.age,a.age)//12 14</code><br><code>function fn(obj) &#123;</code><br>    <code>obj=&#123;age:15&#125;</code><br><code>&#125;</code><br><code>fn(a)</code><br><code>console.log(a.age)//14</code></p><p><strong>原因:</strong></p><ul><li><p><strong>当对象引用发生改变时 被引用对象和引用对象不是同一个对象</strong></p></li><li><p>fn<strong>函数</strong>执行完后内部的局部变量就会<strong>自动释放</strong>，一旦自动释放之后</p></li><li><p>obj对象就会成为垃圾对象，<strong>因此调用a时调用的是变量值为 {name:”Bob”,age:14} 的对象</strong></p></li><li><p>(说白了就是obj和a存储的不是同一个对象地址值 因此obj影响不了a)</p></li><li><p><strong>3.在js调用函数时传递变量参数时，是值传递还是引用传递？</strong></p></li><li><p>答：可能是值传递也可能是，引用传递（地址值）</p></li></ul><h4 id="JS引擎管理内存的方式"><a href="#JS引擎管理内存的方式" class="headerlink" title="JS引擎管理内存的方式"></a>JS引擎管理内存的方式</h4><h5 id="1-内存生命周期"><a href="#1-内存生命周期" class="headerlink" title="1.内存生命周期"></a><strong>1.内存生命周期</strong></h5><ul><li>分配小内存空间，得到它的使用权</li><li>存储数据，可以反复进行操作</li><li>释放小内存空间</li></ul><h5 id="2-释放内存"><a href="#2-释放内存" class="headerlink" title="2.释放内存"></a><strong>2.释放内存</strong></h5><ul><li>局部变量:函数执行完自动释放</li><li>对象:成为垃圾对象–&gt;垃圾回收器回收</li></ul><h3 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h3><h4 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a><strong>什么是对象？</strong></h4><ul><li>多个数据的封装体</li><li>用来保存多个数据的容器</li><li>一个对象代表现实中的一个事物</li></ul><h4 id="为什么要用对象？"><a href="#为什么要用对象？" class="headerlink" title="为什么要用对象？"></a><strong>为什么要用对象？</strong></h4><ul><li>统一管理多个数据</li></ul><h4 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a><strong>对象的组成</strong></h4><ul><li>属性：由属性名（字符串）和属性值（任意类型）组成</li><li>方法：一种特殊的属性（属性值是方法）</li></ul><h4 id="如何访问对象内部数据"><a href="#如何访问对象内部数据" class="headerlink" title="如何访问对象内部数据"></a><strong>如何访问对象内部数据</strong></h4><ul><li><p>.属性名：编码简单，有时不能用</p></li><li><p>[‘属性名’]：编码麻烦，能通用</p><p>​    <strong>使用场景:</strong></p><p>​        1.当属性名包含特殊符号：- 空格时可以使用，而上者不行</p><p>​        2.当变量名不确定时,如:</p><p>​                                <code>var p=&#123;name:&#39;yanghan&#39;&#125;;</code></p><p>​                                <code>var c=&#39;name&#39;;</code></p><p>​                                <code>p.c;//无法获取p的属性yanghan,同时输出的为undefined</code></p><p>​                                <code>p[c];//能获取p的属性yanghan</code></p></li></ul><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h3><h4 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a><strong>什么是函数？</strong></h4><ul><li>实现特定功能的n条语句的封装体</li><li>只有函数是能执行的，其他类型的数据都不能执行</li></ul><h4 id="为什么要使用函数？"><a href="#为什么要使用函数？" class="headerlink" title="为什么要使用函数？"></a><strong>为什么要使用函数？</strong></h4><ul><li>提高代码复用</li><li>便于阅读交流（封装思想）</li></ul><h4 id="如何定义函数？"><a href="#如何定义函数？" class="headerlink" title="如何定义函数？"></a><strong>如何定义函数？</strong></h4><ul><li>函数声明：function xx(){}</li><li>表达式:var xx=function(){}</li></ul><h4 id="如何执行函数？"><a href="#如何执行函数？" class="headerlink" title="如何执行函数？"></a><strong>如何执行函数？</strong></h4><ul><li>test()：直接调用</li><li>obj.test()：通过对象调用</li><li>new test():new调用</li><li>test.call/apply(obj):让函数成为指定对象的方法进行调用</li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><h5 id="什么函数才是回调函数？"><a href="#什么函数才是回调函数？" class="headerlink" title="什么函数才是回调函数？"></a><strong>什么函数才是回调函数？</strong></h5><ul><li>自身定义的函数</li><li>你没调用该函数，但该函数自动执行了</li></ul><h5 id="常见的回调函数"><a href="#常见的回调函数" class="headerlink" title="常见的回调函数"></a><strong>常见的回调函数</strong></h5><ul><li>dom对象回调函数</li><li>定时器回调函数（定时器:循环定时器、一次性定时器）</li><li>ajax请求回调函数</li><li>生命周期回调函数</li></ul><h4 id="IIFE（立即执行调用函数表达式）"><a href="#IIFE（立即执行调用函数表达式）" class="headerlink" title="IIFE（立即执行调用函数表达式）"></a><strong>IIFE（立即执行调用函数表达式）</strong></h4><p>匿名函数自调用</p><p><code>( function()&#123;</code><br>    <code>var a=3;</code><br>    <code>console.log(a+3)</code><br><code>&#125;)()</code></p><p>作用:</p><p>​    实现隐藏</p><p>​    不会污染外部（全局）命名空间</p><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p><strong>什么是this?</strong></p><ul><li>任何函数本质都是通过某个对象来调用的，如果没指定就是window对象调用</li><li>所有函数内部都有一个变量this</li><li>它的值是调用函数的当前对象</li></ul><p><strong>如何确定this值?</strong></p><ul><li>test()：window</li><li>p.test()：p</li><li>new est()：创建对象</li><li>p.call(obj):obj</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Jquery</title>
      <link href="/2021/06/22/%E5%88%9D%E8%AF%86Jquery/"/>
      <url>/2021/06/22/%E5%88%9D%E8%AF%86Jquery/</url>
      
        <content type="html"><![CDATA[<p>初始jQuery<br>什么是jQuery<br>jQuery是一个快速、简洁的javascript库，它里面封装了JavaScript常用大的功能代码，优化了DOM操作、事件处理、动画设计和Ajax交互，学习jQuery的本质就是学习调用这些函数（方法）；</p><p>jQuery的优点<br>轻量级。核心文件才几十kb，不会影响页面大的加载速度<br>跨浏览器兼容。基本兼容了现在主流大的浏览器<br>链式编程，隐式迭代 ( 隐式迭代就是把匹配的所有元素内部进行遍历循环)<br>对事件、样式、动画支持，大大简化大的DOM操作<br>支持插件扩展开发。有着丰富大的第三方插件，如树形菜单、日期控件、轮播图等<br>免费、开源<br>简单的使用jQuery<br>1.jQuery的入口函数</p><pre><code>$(function() &#123;   $(&#39;div&#39;).hide();//此处是DOM加载完成的入口，相当与原生的DOMContentLoaded &#125;)</code></pre><p>2.jQuery的顶级对象$</p><p>​ $是jQuery的别称，在代码中jQuery和$可以互换</p><p>​ $是jQuery的顶级对象，相当于原生的的window，帮元素利用$包装成jQuery对象，就可以调用jQuery的方法。</p><p>DOM对象和jQuery对象的区别<br>用原生js获取来的对象就是DOM对象</p><p>var myDiv = document.querySelector(‘div’); // myDiv 是DOM对象<br>jQuery方法获取的元素就是jQuery对象</p><p>$(‘div’); // $(‘div’)是一个jQuery 对象<br>jQuery对象的本质是：利用$对DOM对象大的包装后生产的对象（伪数组形式储存）</p><p>DOM对象和jQuery对象之间是可以相互转换的</p><p>因为原生js比jQuery更大，原生的一些属性和方法jQuery没有给我们封装。要是想要这些属性和方法需要把和jQuery对象转换成DOM对象才能使用</p><p>DOM对象转换为jQuery对象 $(DOM对象)<br>$(‘div’)<br>jQuery对象转换为DOM对象(两种方式)<br>$(‘div’)[index]   //index是索引号<br>$(‘div’).get(index)<br>jQuery的基本操作<br>能写出常用的jQuery选择器<br>基础选择器<br>$(“选择器”)   //直接写css选择器，但是一定要加双引号<br>用法    名称    描述<br>$(“#id”)    Id选择器    获取指定ID元素<br>$(“*”)    全选选择器    匹配所有元素<br>$(“.class”)    类选择器    获取同一类元素<br>$(“div”)    标签选择器    获取同一类标签的所有元素<br>$(“div,p,li”)    并集选择器    选取多个元素<br>$(“li.current”)    交集选择器    交集元素<br>层级选择器<br>名称    用法    描述<br>子代选择器    $(“ul&gt;li”)    使用&gt;号，获取亲儿子层级的元素；注意不会获取到孙子层级的元素<br>后代选择器    $(“ul li”)    使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子<br>筛选选择器<br>语法    用法    描述<br>:first    $(“li:first”)    获取第一个li元素<br>:last    $(“li:last”)    获取最后一个li元素<br>:ed(index)    $(“li:ed(2)”)    获取li元素中，选择索引号为2的元素<br>:odd    $(“li:odd”)    获取li元素中，选择索引号为奇数的元素<br>:even    $(“li:even”)    获取li元素中,选择索引号为偶数的元素<br>筛选方法(重点)<br>语法    用法    说明<br>parent()    $(“li”).parent();    查找父级<br>children(selector)    $(“ul”).children(“li”);    相当于$(“ul&gt;li”),最近一级(亲儿子)<br>find(selector)    $(“ul”).find(“li”);    相当于$(“ul li”),后代选择器<br>siblings(selector)    $(“.first”).siblings(“li”);    查找兄弟节点。不包括自己<br>nextAll([expr])    $(“.first”).nextAll()    查找当前元素之后所有的同辈元素<br>prevtAll([expr])    $(“.last”).pravAll()    查找当前元素之前所有的同辈元素<br>hasClass(class)    $(“div”).hasClass(“protected”)    查找当前元素是否含有某个特定的类，如果有则返回true<br>eq(index)    $(“li”).eq(2)    相当于$(“li:eq(2)”),index从0开始<br>重点记住：parent() children() find() siblings() eq()</p><p>能够操作jQuery样式<br>操作css方法<br>jQuery可以使用css方法来修改简单元素样式；也可以操作类，修改多个样式。</p><p>1.参数只写属性名，则返回属性值</p><p>$(this).css(“color”);<br>2.参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用单位和引号</p><p>$(this.css(“color”,”red”);<br>3.参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不加引号</p><p>$(this).css(“color”:”white”,”font-size”:”20px”)<br>设置类样式方法<br>作用等同于以前的classList，可以操作类样式，注意操作类里面的参数不要加点</p><p>1.添加类</p><p>$(“div”).addClass(“current”);<br>2.移除类</p><p>$(“div”).removeClass(“current”);<br>3.切换类</p><p>$(“div”).toggleClass(“current”);<br>类操作与ClassName区别<br>原生js中的ClassName会覆盖原先里面的类名</p><p>jQuery里面的类操作只是对指定类进行操作，不会影响原先的类名。</p><p>能够写出常用的jQuery动画<br>1.显示隐藏 show() hide() toggle()<br>show([speed,[easing],[fn]])<br>//(1) 参数都可以省略，无动画直接显示<br>  (2)speed：三种预定速度之一的字符串(“slow”,”narmal”,”fast”)或者表示动画时长的毫秒数值<br>  (3)easing:(Optional)用来指定切换效果，默认是”swing”，可用参数”linear”.<br>  (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次<br>  下面的相同<br>2.滑动 sideDown() sideUp() sideToggle()<br>3.淡入淡出 fadeIn() fadeOut() fadeToggle() fadeTo()<br>fadeTo(speed,opacity,[easing],[fn])<br>//(1)opacity 透明度必须写，取值0-1之间<br>  (2)speed 三种预定速度之一的字符串(“slow”,”narmal”,”fast”)或者表示动画时长的毫秒数值必须写<br>4.自定义动画 animate()<br>animate(params,[speed],[easing],[fn])<br>//params 想要更改的属性，以对象的形式传递，必须写，属性名可以不写引号，复合属性采用驼峰命名方式<br>5.动画或效果队列及其停止排队方法<br>动画或者效果一旦触发就会执行，如果多次触发，就会造成多个动画或者效果排队执行。</p><p>stop()  //用于停止动画或者效果，一定要写到动画前面，相当于停止结束上一次的动画<br>能够操作jQuery属性<br>设置获取元素固有属性值prop()<br>所谓元素固有属性就是元素本身自带的属性；</p><p>1.获取属性的语法<br>prop(“属性”)<br>2.设置属性语法<br>prop(“属性”，”属性值”)<br>设置或获取元素自定义属性attr()<br>用户给元素添加大的属性；</p><p>1.获取属性语法<br>attr(“属性”)   //类似原生getAttribute<br>2.设置属性语法<br>attr(“属性”,”属性值”)   //类似原生setAttribute<br>数据缓存data()<br>data() 方法可以在指定的元素上存取数据，并不会修改DOM元素结构。一旦页面刷新，之前存放的数据都会移除。</p><p>1.附加数据语法<br>data(“name”,”value”)  //向被选元素附加数据<br>2.获取数据语法<br>data(“name”)  //向被选元素获取数据<br>同时还可以读取HTML5自定义属性data-index，得到的是数字型</p><p>能够操作jQuery元素<br>内容文本值<br>主要针对元素的内容还有表单的值操作</p><p>1.普通元素内容html()(相当于原生inneHTML)<br>html()  //获取元素的内容<br>html(“内容”) //设置元素的内容<br>2.普通元素文本内容text() (相当与原生innerText)<br>text()   //获取元素文本内容<br>text(“文本内容”)  //设置元素文本内容<br>3.表单的值val()(相当于原生value)<br>遍历元素<br>jQuery隐式迭代是对同一类元素作了同样的操作，如果想要给同一类做不同的操作，就要用到遍历</p><p>语法1<br>$(“div”).each(function(index,domEle){xxx;})<br>1.each()方法遍历匹配的每一个元素。主要用DOM处理。each每一个</p><p>2.里面大的回调函数有两个参数：index是每个元素的索引号；domEle是每隔DOM元素对象不是jQuery对象</p><p>3.所以想要使用jQuery方法，需要给这个dom元素转换为jQuery对象$(domEle)</p><p>语法2<br>$.each(object,function(index,element){xxx;})<br>1.$.each()方法可用于遍历任何对象，主要是数据处理。比如数组对象</p><p>2.里面的函数有2个参数：index是每个元素的索引号；element遍历内容</p><p>添加元素<br>1.内部添加<br>element.append(“内容”)<br>把内容放入匹配元素内部最后面，类似原生appendChild</p><p>element.prapend(“内容”)<br>2.外部添加<br>element.after(“内容”)   //把内容放入目标元素后面<br>element.before(“内容”)   //把内容放入目标元素前面<br>内部添加元素，生成之后，他们是父子关系</p><p>外部添加元素，生成之后，他们是兄弟关系</p><p>删除元素<br>element.remove()  //删除匹配的元素（本身）<br>element.empty()  //删除匹配的元素集合中的所有子节点<br>element.html(“”)   //清空匹配的元素内容<br>事件处理<br>事件处理on()绑定事件<br>on()方法在匹配元素上绑定一个或多个事件处理函数</p><p>element.on(events,[selector],fn)<br>1.events:一个或多个空格分隔的事件类型，如click或者keydown</p><p>2.selector：元素的子元素选择器</p><p>3.fn：回调函数，即绑定在元素身上的侦听函数</p><p>on()方法的优势<br>1.可以绑定多个事件 多个事件处理程序<br>$(“div”).on({<br>mouseover:function(){},<br>mouseout:function(){},<br>click:function(){}<br>});<br>如果事件处理程序相同</p><p>$(“div”).on(“mouseover mouseout”,function(){<br>$(this).toggleClass(“current”);<br>});<br>2.可以事件委派操作，事件委派的定义就是，把原来加给子元素事件绑定在父元素身上，就是把事件委派给父元素<br>$(‘ul’).on(‘click’,’li’,function(){<br>    alert(‘hello world!’);<br>});<br>在此之前有bind(),live() delegate()等方法来处理事件绑定或者事件委派，最新版用on代替他们</p><p>3.动态创建的元素，click()没有办法绑定事件，on()可以给动态生成的元素绑定事件<br>事件处理off()解绑事件<br>off()方法可以移除通过on()方法添加的事件处理程序</p><p>$(“p”).off()   //解绑p元素所有事件处理程序<br>$(“p”).off(“click”)   //解绑p元素上面的点击事件<br>$(“ul”).off(“click”,”li”);   //解绑事件委托<br>如果事件只想触发一次，可以使用one()来绑定事件</p><p>自动触发事件trigger()<br>有些时间希望自动触发，比如轮播图自动播放功能跟点击右侧按钮一致，可以利用定时器自动触发右侧按钮的点击事件，不必鼠标点击触发</p><p>element.click()  //第一种简写方式<br>element.trigger(“type”)  //第二种自动触发模式<br>$(“p”).on(“click”,function(){<br>alert(“hi~”);<br>});<br>$(“p”).trigger(“click”);    //此时自动触发点击事件，不需要鼠标点击<br>jQuery事件对象<br>事件被触发，就会有事件对象的产生。</p><p>element.on(events,[selector],function(event){})<br>阻止默认行为：event.preventDefault() 或者 return false</p><p>阻止冒泡：event.stopPropagation</p><p>jQuery对象拷贝<br>如果想要把某个对象拷贝（合并）给另外一个对象使用，此时可以使用$.extend()方法</p><p>$.extend([deep],target,object,[objectN])<br>1.deep:如果设为true为深拷贝，默认false为浅拷贝</p><p>2.target：要拷贝的目标对象</p><p>3.object1：代拷贝到第一个对象的对象</p><p>4.objectN：待拷贝到第N个对象的对象</p><p>5.浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象</p><p>6.深拷贝，前面加true，完全克隆（拷贝的对象，而不是地址），修改的目标对象不会影响被拷贝的对象。</p><p>jQuery多库共存<br>jQuery使用$作为标识符随着jQuery的流行，其他js库也用这$作为标识符，这样一来就会引起冲突。需要一个解决方案，让jQuery和其他的js和其他的js库不存在冲突，可以同时存在。这就叫做多库共存。</p><p>解决方案<br>1.把里面的$符号统一改为jQuery。比如jQuery(“div”)</p><p>2.jQuery变量规定新的名称：$.noConflict() 如： var xxx =$.noConflict();</p><p>jQuery插件<br>1.jQuery插件库 <a href="http://www.jq22.com/">http://www.jq22.com/</a></p><p>2.jQuery之家<a href="http://www.htmleaf.com/">http://www.htmleaf.com/</a></p><p>使用步骤<br>1.引入相关文件（jQuery文件和插件文件）</p><p>2.复制相关的html，css，js（调用插件）</p><p>常用插件<br>1.瀑布流</p><p>2.图片懒加载(图片使用延迟加载在可提高网页下载速度，它也能帮助减轻服务器负载)</p><p>当我们页面滑动得到可视区域，在显示图片，使用插件库的EasyLazyload，注意此时引入的文件和js调用必须写在DOM元素（图片）最后面</p><p>3.全屏滚动（fullpage.js)</p><p>GitHub：<a href="https://github.com/alvarotrigo/fullPage.js">https://github.com/alvarotrigo/fullPage.js</a></p><p>中文翻译网：<a href="http://www.dowebok.com/demo/2014/77/">http://www.dowebok.com/demo/2014/77/</a></p><p>bootstrap中文文档<a href="https://v3.bootcss.com/">https://v3.bootcss.com</a></p><p>能够操作jQuery元素尺寸、位置<br>jQuery尺寸<br>语法    用法<br>width()/height()    取得匹配元素宽度和高度值 只算width/height<br>innerWidth() /innerHeight()    取得匹配元素宽度和高度值 包含padding<br>outerWidth()/outerheight()    取得匹配元素的宽度和高度值 包含padding、border<br>outerWidth(ture)/outerHeight(ture)    取得匹配元素宽度和高度值 包含padding、border、margin<br>以上参数为空，则是获取相应值，返回的是 数字型</p><p>如果参数为数字，则是修改相应值</p><p>参数可以不必写单位</p><p>jQuery位置<br>位置主要有三个：offset()、position()、scrollTop()/scrollLeft()</p><p>1.offset()设置或获取元素偏移<br>offset()方法设置或返回被选中元素相当于文档的偏移坐标，跟父级没有关系</p><p>该方法有2个属性left、top、offset()、top 用于获取距离文档顶部的距离，offset().left用于获取距离文档左侧的距离。</p><p>可以设置元素的偏移：offset({top:10,left:30});</p><p>2.position() 获取元素偏移<br>position()方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准。这个方法只能获取不能设置偏移。</p><p>3.scrollTop() /scrollLeft()设置或获取元素被卷去的头不和左侧<br>srcollTop()方法设置或返回被选元素被卷去的头部</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的后端学习路线</title>
      <link href="/2021/06/16/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2021/06/16/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h4 id="第一阶段：Java基础知识-培养编程思维"><a href="#第一阶段：Java基础知识-培养编程思维" class="headerlink" title="第一阶段：Java基础知识(培养编程思维)"></a><strong>第一阶段：Java基础知识(培养编程思维)</strong></h4><blockquote><p>变量、数据类型、运算符</p><p>控制语句(循环嵌套多思考)</p><p>面向对象编程(转折点!作为初学者这块可能会很难!)</p><p>异常机制</p><p>Java常用类(API)</p><p>集合(代替数组 后期常用到)</p><p>iO流</p><p>多线程</p><p>网络编程</p></blockquote><h4 id="第二阶段：数据库阶段-后期都要连库操作"><a href="#第二阶段：数据库阶段-后期都要连库操作" class="headerlink" title="第二阶段：数据库阶段(后期都要连库操作)"></a><strong>第二阶段：数据库阶段(后期都要连库操作)</strong></h4><blockquote><p>MysSQL入门</p><p>DML（数据库操作语言）</p><p>DCL（数据库控制语言）</p><p>DDL（数据库定义语言）</p><p>单表查询</p><p>多表查询-内连接查询</p><p>多表查询-外连接查询</p><p>多表查询-子查询</p><p>视图</p><p>事务</p><p>索引</p><p>三大范式</p><p>存储过程</p></blockquote><h4 id="第三阶段：JDBC和GUi（学习MVC设计模式）"><a href="#第三阶段：JDBC和GUi（学习MVC设计模式）" class="headerlink" title="第三阶段：JDBC和GUi（学习MVC设计模式）"></a><strong>第三阶段：JDBC和GUi（学习MVC设计模式）</strong></h4><blockquote><p>GUI</p><p>JDBC及案例</p><p>使用properties读取属性文件</p><p>JDBC+GUI实现简易的程序（重点）</p></blockquote><h4 id="第四阶段：WEB前端-后端也需学一些前端知识-但没必要太过精通"><a href="#第四阶段：WEB前端-后端也需学一些前端知识-但没必要太过精通" class="headerlink" title="第四阶段：WEB前端(后端也需学一些前端知识 但没必要太过精通)"></a><strong>第四阶段：WEB前端(后端也需学一些前端知识 但没必要太过精通)</strong></h4><blockquote><p>HTML5</p><p>CSS3</p><p>JavaScript(可以选择精学)</p></blockquote><h4 id="第五阶段：JavaWeb"><a href="#第五阶段：JavaWeb" class="headerlink" title="第五阶段：JavaWeb"></a><strong>第五阶段：JavaWeb</strong></h4><blockquote><p>Tomcat与HTTF</p><p>Servlet(JavaWeb三大组件之一 spring框架底层技术需精学)</p><p>文件下载练习</p><p>JSP基础语法</p><p>EL</p><p>JSTL</p><p>Cookie</p><p>Session</p><p>Filter(JavaWeb三大组件之一)</p><p>listener(avaWeb三大组件之一)</p><p>MVC架构</p><p>JSON</p><p>Ajax</p><p>项目实战</p></blockquote><h4 id="第六阶段：框架"><a href="#第六阶段：框架" class="headerlink" title="第六阶段：框架"></a><strong>第六阶段：框架</strong></h4><blockquote><p>jquery(JavaScript的框架)</p><p>vue(JavaScript的框架)</p><p>SSM(常见的三大框架)</p></blockquote><p><strong>以上为个除了框架未学，其他均为个人大一所学的知识 知识全部从网上视频、书籍中所获取</strong></p><p><strong>能获取的资源有限，可能上述有些旧知识，请选择性参考!</strong></p><h6 id="可能此次总结不到位，此文章将持续更新"><a href="#可能此次总结不到位，此文章将持续更新" class="headerlink" title="可能此次总结不到位，此文章将持续更新!"></a><strong>可能此次总结不到位，此文章将持续更新!</strong></h6>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA的安装和开发工具的选择</title>
      <link href="/2021/06/16/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/"/>
      <url>/2021/06/16/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h4 id="JDK的安装"><a href="#JDK的安装" class="headerlink" title="JDK的安装"></a>JDK的安装</h4><p><strong>首先JDK的下载:</strong></p><p>去官网下载相应的JDK版本，这边推荐下载<strong>JDK的解压版</strong> 下载完配置完环境即可用，</p><p>不需要时删除即可,如果需要更改版本直接修改配置环境即可。</p><p>现在市面上用的最多的jdk版本为jdk8,因此下载推荐下载jdk8或者之上的版本</p><p><strong>环境变量的配置:</strong></p><p>1.此电脑→属性→高级系统设置→高级</p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img1.png"></p><p><img src="/image/img2.png"></p><p>2.选择环境变量→新建一个系统变量</p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img3-1624098983658.png"></p><p>变量名为<strong>JAVA_HOME</strong>  变量值为<strong>JAVA的绝对路径</strong></p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img4-1624098999268.png"></p><p>3.双击path→新建一个环境变量</p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img5.png"></p><p>4.给path添加一个新的环境变量名为:<strong>%JAVA_HOME%\bin</strong></p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img6.png"></p><p><u>ps:如果电脑不支持双击进入编辑界面 可以直接在path的值中添加：%JAVA_HOME%\bin;</u></p><h4 id="开发工具的选择"><a href="#开发工具的选择" class="headerlink" title="开发工具的选择"></a>开发工具的选择</h4><p>这里强烈不推荐eclipse!时代在前进而不是倒退,既然有比eclipse更强的<strong>idea</strong></p><p>为什么不用呢？所以推荐使用<strong>idea idea</strong>有着更方便的快捷键 有着更人性化的</p><p>设置。但完整版需付费 因此需动动小手破解一下</p><p>链接：<a href="https://pan.baidu.com/s/1HkUheAc21iyidsc5yGTkTA">https://pan.baidu.com/s/1HkUheAc21iyidsc5yGTkTA</a><br>提取码：lcbn </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
