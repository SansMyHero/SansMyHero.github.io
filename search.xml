<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>request和response入门</title>
      <link href="/2021/06/29/request%E5%92%8Cresponse%E5%85%A5%E9%97%A8/"/>
      <url>/2021/06/29/request%E5%92%8Cresponse%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="request和response对象的原理"><a href="#request和response对象的原理" class="headerlink" title="request和response对象的原理"></a><strong>request和response对象的原理</strong></h5><h4 id="request入门"><a href="#request入门" class="headerlink" title="request入门"></a>request入门</h4><ol><li>tomcat服务器会根据请求url中的资源路径，去创建对应的Servlet实现类对象。</li><li>tomcat服务器，会创建request和response对象，requset对象中封装请求消息数据。</li><li>tomcat将request和response两个对象传递给service方法，并调用service方法。</li><li>程序员，通过request对象获取请求消息数据，可以通过response对象设置响应消息数据。</li><li>服务器再给浏览器做出响应之前，会从response对象中拿程序员设置的的响应消息数据。</li></ol><h5 id="requset对象继承体系结构"><a href="#requset对象继承体系结构" class="headerlink" title="requset对象继承体系结构"></a><strong>requset对象继承体系结构</strong></h5><p>ServletRequset –接口</p><p>​            |    继承</p><p>HttpServletRequset –接口</p><p>​            |    实现</p><p>org.apache.catalina.connector.RequsetFacade类(由tomcat实现)</p><h5 id="request功能"><a href="#request功能" class="headerlink" title="request功能"></a><strong>request功能</strong></h5><ul><li>获取请求消息数据</li></ul><ol><li><p>​    获取请求行数据</p><ul><li>获取请求方式：GET<ul><li>String getMethod()</li></ul></li><li>获取虚拟目录：/day14<ul><li>String getContextPath()</li></ul></li><li>获取Servlet路径：/demo1<ul><li>String getServlePath()</li></ul></li><li>获取get方式请求参数：name=zhangsan<ul><li>getQueryString()</li></ul></li><li>获取请求的uri：/day14/demo1<ul><li>String getRequestURI()：统一资源标识符</li><li>StringBuffer getRequestURL()：ton</li></ul></li><li>获取协议及版本号：HTTP/1.1<ul><li>String getProtocol()</li></ul></li><li>获取客户机的ip地址（ip6）:<ul><li>String getRemoteAddr()</li></ul></li></ul></li><li><p>​    获取请求头数据</p><ul><li>方法：<ul><li>String getHeader(String name)：通过请求头的名称 获取请求头的值</li><li>getHearderNames()：获取所有的请求头名称</li></ul></li></ul></li><li><p>​    获取请求体数据</p><ol><li><p>请求体:只有POST请求中，才有请求体，在请求体中封装了POST请求的请求参数</p></li><li><p>步骤：</p><ol><li>获取流对象<ul><li>BufferedReader getReader()：获取字符输入流</li><li> ServletInputStream getInputStream()：获取字节输入流</li></ul></li></ol></li></ol></li><li><p>再从流当中获取数据</p></li></ol><h5 id="其它功能："><a href="#其它功能：" class="headerlink" title="其它功能："></a><strong>其它功能：</strong></h5><ol><li>获取请求参数通用方式<ul><li>String getParameter(String name)：根据参数名称获取参数值</li><li>String[] getParameterValues(String name)：根据参数名称获取参数值的数组</li><li>Enumeration&lt;String&gt; getParameterNames()：获取所有请求参数的名称</li><li>Map&lt;String,String[]&gt; getParameterMap()：获取所有参数键值对的map集合</li></ul></li><li>请求转发：一种在服务器内部的资源跳转方式<ul><li>步骤:<ul><li>通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)</li><li>使用forward(ServletRequest request,ServletResponse response)方法进行转发</li></ul></li><li>特点<ul><li>转发时浏览器地址路径不发生变化</li><li>只能转发到当前服务器的内部资源中</li><li>转发是一次请求</li></ul></li></ul></li><li>共享数据<ul><li>域对象：一个有作用范围的对象，可以在访问内共享数据</li><li>request域 ：代表一次请求的范围，一般用于请求转发的多个资源中共享数据<ul><li>方法:<ul><li>setAttribute(String name,Object obj)：存储数据</li><li>Object getAttribute(String name)：通过键获取数据</li><li>removeAttribute(String name)：通过键名移除键值对</li></ul></li></ul></li></ul></li><li>获取ServletContext<ul><li>ServletContext getServletContext()</li></ul></li></ol><h5 id="解决乱码问题"><a href="#解决乱码问题" class="headerlink" title="解决乱码问题"></a><strong>解决乱码问题</strong></h5><ul><li>get方式：tomcat 8 已经将get方式的乱码问题解决</li><li>post方式：会乱码<ul><li>解决：设置流的字符集：request.setCharacterEncoding(“utf-8”)</li></ul></li></ul><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h5><ul><li><p>BeanUtils的基本使用:</p><ul><li>获取请求参数Map集合</li><li>创建JavaBean实例对象</li><li>调用:BeanUtils.populate(Object bean,Map properties)</li></ul></li><li><p>JavaBean：标准的Java类</p><ul><li><p>要求:</p><ul><li>类必须被public修饰</li><li>必须提供空参的构造器</li><li>成员变量必须使用private修饰</li><li>提供公共的setter和getter方法</li></ul></li><li><p>功能：封装数据</p></li></ul></li><li><p>成员变量：</p></li><li><p>属性：setter和getter方法截取后的产物</p><ul><li>例如：getUsername() –&gt; Username –&gt; username</li></ul></li></ul><h4 id="response入门"><a href="#response入门" class="headerlink" title="response入门"></a>response入门</h4><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><ul><li>设置响应消息</li><li>设置响应行<ul><li>格式：HTTP/1.1       200    OK</li><li>设置状态码：setStatus(int sc)</li></ul></li><li>设置响应头：setHeader(String name,String value)</li><li>设置响应体：<ul><li>使用步骤：</li><li>获取输出流<ul><li>字符输出流：printWriter getWriter()</li><li>字节输出流：ServletOutputStream getOutputStream()</li></ul></li><li>使用输出流,将数据输出到客户端浏览器</li></ul></li></ul><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向:"></a>重定向:</h5><p><strong>实现:</strong></p><ol><li><p>设置状态码为302</p></li><li><p>设置响应头location</p><p><strong>简单的重定向方法：sendRedirect(“资源路径”)</strong></p></li></ol><p><strong>转发与重定向的区别</strong></p><ul><li><p>重定向的特点：redirect</p><ul><li>地址栏发生变化</li><li>重定向可以访问其他站点（服务器）的资源</li><li>重定向是两次请求。不能使用request共享数据</li></ul></li><li><p>转发的特点：forward</p><ul><li>转发地址栏路径不变</li><li>转发只能访问当前服务器下的资源</li><li>转发是一次请求</li></ul></li></ul><h5 id="路径写法"><a href="#路径写法" class="headerlink" title="路径写法"></a><strong>路径写法</strong></h5><ul><li>相对路径：通过相对路径不可以确定唯一资源<ul><li>不以/开头，以.开头的路径</li><li>规则：找到当前资源与目标资源之间的相对位置关系<ul><li>./：当前目录</li><li>../：后退一级目录</li></ul></li></ul></li><li>绝对路径：通过绝对路径可以确定唯一资源<ul><li>以/开头的路径</li><li>规则：判断定义的路径是给谁用的？判断请求从拿发出<ul><li>给客户端浏览器使用：需加虚拟目录</li><li>给服务器使用（转发）：不需要加虚拟目录</li></ul></li></ul></li></ul><h5 id="输出字符数据出现乱码问题"><a href="#输出字符数据出现乱码问题" class="headerlink" title="输出字符数据出现乱码问题"></a>输出字符数据出现乱码问题</h5><p>**原因:**浏览器解码的编码与tomcat获取流对象的编码不相同</p><p><strong>解决:</strong></p><ul><li><p>使用setCharacterEncoding()将流对象的编码设置成与浏览器相同</p><p>但此方法有局限性，因为浏览器编码会随着系统环境变化而变化</p></li><li><p>使用setHeader(“content-type”,”text/html;charset=utf-8”)</p><p>告诉浏览器使用utf-8解码,来解决上述问题（设置了此项可以不用设置第一项）</p></li><li><p>使用setContentType()是上述方法的简写形式</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP入门学习</title>
      <link href="/2021/06/28/HTTP%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/28/HTTP%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="概念：Hypertext-Transfer-Protocol超文本传输协议"><a href="#概念：Hypertext-Transfer-Protocol超文本传输协议" class="headerlink" title="概念：Hypertext Transfer Protocol超文本传输协议"></a>概念：Hypertext Transfer Protocol超文本传输协议</h4><h5 id="传输协议："><a href="#传输协议：" class="headerlink" title="传输协议："></a><strong>传输协议</strong>：</h5><ul><li>定义了，客户端和服务器通信时，发送数据的格式</li></ul><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点</strong>：</h5><ul><li>基于TCP/IP的高级协议</li><li>默认端口号：80</li><li>基于请求/响应模型的：一次请求对应一次响应</li><li>无状态的：每次请求相互独立，不能交互数据</li></ul><h5 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本:"></a><strong>历史版本</strong>:</h5><ul><li>1.0：每一次请求响应都会建立新的连接</li><li>1.1：复用连接（等待一段时间看看是否还有请求）</li></ul><h5 id="请求消息数据格式："><a href="#请求消息数据格式：" class="headerlink" title="请求消息数据格式："></a><strong>请求消息数据格式</strong>：</h5><ul><li><p>请求行</p><p>请求方式  请求的url       请求协议/版本</p><p>GET           /index.html   HTTP/1.1</p></li><li><p>请求头</p><p>请求头名称 : 请求头值</p></li><li><p>请求空行</p><p>空行</p></li><li><p>请求体</p><p>POST请求中可以获取到</p><p>username=zhangshan</p></li></ul><h5 id="请求方式："><a href="#请求方式：" class="headerlink" title="请求方式："></a><strong>请求方式</strong>：</h5><p>HTTP协议中有7种请求方式，常用的有两种</p><ul><li>GET: </li></ul><p>​            请求参数在请求行中，在url后。</p><p>​            请求的url长度有限制的（POST没有限制）</p><p>​            不太安全</p><ul><li>POST:</li></ul><p>​            请求参数在请求体中</p><p>​            相对安全</p><h5 id="常见的请求头"><a href="#常见的请求头" class="headerlink" title="常见的请求头"></a><strong>常见的请求头</strong></h5><ul><li><p>User-Agent：浏览器告诉服务器，访问使用的浏览器版本信息</p><p>可以在浏览器获取该头的信息，来解决不同浏览器的兼容问题</p></li><li><p>Referer：告诉服务器，请求从哪来</p><p>作用：</p><p>​        1.防盗链</p><p>​        2.统计工作</p></li></ul><h5 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h5><ul><li><p>响应行</p><ul><li><p>组成：协议/版本 响应状态码 状态码描述</p><p>​            HTTP/1.1         200            OK</p></li><li><p>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。</p><ul><li>状态码都是3位数<ul><li>分类：<ul><li>1xx：服务器接受客户端消息，但没有接受完成，等待一段时间后，发送1xx状态码。</li><li>2xx：成功。</li><li>3xx：重定向。代表：302（重定向），304（访问缓存）。</li><li>4xx：客户端错误。</li><li>5xx：服务器端错误。</li></ul></li></ul></li></ul></li></ul></li><li><p>响应头</p><ul><li>常见响应头</li><li>Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式</li><li>Content-disposition：服务器告诉客户端以什么格式打开响应数据<ul><li>值：</li><li>in-line：默认值，在当前页面打开</li><li>attachment：以附件形式打开响应体。文件下载</li></ul></li></ul></li><li><p>响应空行</p></li><li><p>响应体：传输的数据</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servelt入门学习</title>
      <link href="/2021/06/28/Servelt%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/28/Servelt%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="概念：Server-Apple-服务器小程序"><a href="#概念：Server-Apple-服务器小程序" class="headerlink" title="概念：Server Apple 服务器小程序"></a>概念：Server Apple 服务器小程序</h4><ul><li>运行在服务器端的小程序</li><li>Servlet就是一个接口，定义了Java类被浏览器访问到（tomcat识别）的规则</li></ul><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ol><li><p>创建JavaEE项目</p></li><li><p>定义一个类实现Servlet接口，并且实现接口中的抽象方法</p></li><li><p>在web.xml中配置servlet，格式入下：</p><p><code>&lt;servlet&gt;</code></p><p><code>&lt;servlet-name&gt;name&lt;/servlet-name&gt;</code></p><p><code>&lt;servlet-class&gt;实现Servlet接口类的**全类名**&lt;/servlet-class&gt;</code></p><p><code>&lt;/servlet&gt;</code></p><p><code>&lt;servlet-mapping&gt;</code></p><p><code>&lt;servlet-name&gt;name&lt;/servlet-name&gt;</code></p><p><code>&lt;url-pattern&gt;在浏览器访问资源的路径&lt;/url-pattern&gt;</code></p><p><code>&lt;/servlet-mapping&gt;</code></p></li></ol><h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4><ol><li>当服务器接受到客户端浏览器的请求后，会解析url的请求路径（找tomcat 找tomcat部署的项目），获取访问的Servlet的资源路径</li><li>查找web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容 。</li><li>如果有则通过<code>&lt;servlet-name&gt;</code>标签体的内容，找到&lt;servlet&gt;标签中的<code>&lt;servlet-class&gt;</code>标签中的全类名</li><li>tomcat将字节码文件加载进内存 再创建其对象</li><li>调用其方法</li></ol><h4 id="Servlet方法"><a href="#Servlet方法" class="headerlink" title="Servlet方法"></a>Servlet方法</h4><p><strong>生命周期方法：</strong></p><ul><li><p>public void init(ServletConfig servletConfig)：初始化方法在Servlet被创建时调用</p><p><strong>Servlet的init方法只执行一次 ，说明Servlet在内存中只存在一个对象，Servlet是单例的</strong></p><p><strong>当多个用户进行访问同一个对象时，可能存在线程安全问题</strong></p><p><strong>解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量也不要修改其值</strong></p></li><li><p>public void service(ServletRequest servletRequest, ServletResponse servletResponse)：提供服务的方法 每次Servlet被访问时执行</p></li><li><p>public void destroy()：服务器正常关闭时执行</p></li></ul><p>其他方法：</p><ul><li>public ServletConfig getServletConfig()：获取Servlet配置对象的方法(通过配置对象对Servlet进行操作)</li><li>public String getServletInfo()：获取Servlet信息的方法（版本、作者等）</li></ul><h4 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h4><p><strong>Servlet在什么时候被创建？</strong></p><ul><li>默认情况下，第一次访问时，Servlet被创建</li><li>可以配置<code>&lt;load-on-startup&gt;</code>标签来实现不同时候创建</li><li>当值为正数或0时:在服务器启动时创建</li><li>当值为负数时：第一次被访问时创建</li></ul><h4 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h4><p><strong>好处：</strong></p><p>支持注解配置。可以不需要web.xml了</p><p><strong>使用：</strong></p><p>给实现了Servlet的类添加注解：@WebServlet(“资源路径”)</p><h4 id="Servlet体系"><a href="#Servlet体系" class="headerlink" title="Servlet体系"></a>Servlet体系</h4><p>Servlet –接口</p><p>​    |</p><p>genericServlet –抽象类(只将service方法抽象 其他方法都中实现了)</p><p>​    |</p><p>HttpServlet –抽象类</p><p><strong>HttpServlet在service方法中干了下面这件事:</strong></p><p><code>//判断请求方式</code><br><code>String method=req.getMethod();</code><br><code>if (&quot;GET&quot;.equals(method))&#123;</code><br>    <code>//get方式获取数据</code></p><p>​    <code>    doGet()</code></p><p><code>&#125;else if (&quot;POST&quot;.equals(method))&#123;</code><br>    <code>//post方式请求数据</code></p><p>​    <code>doPost()</code></p><p><code>&#125;</code></p><p>因此继承HttpServlet只用实现doGet()和doPost()方法</p><p><strong>url-pattern</strong></p><ol><li>Servlet的资源路径可以配置多个</li><li>路径定义规则:</li></ol><p>​                /xxx</p><p>​                /xxx/xxx：多层路径，目录结构</p><p>​                *.do</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程中遇到的一些小问题</title>
      <link href="/2021/06/28/%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2021/06/28/%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>时间</th><th>问题</th><th>解决方案</th></tr></thead><tbody><tr><td>2021/6/28</td><td>使用Ajax请求时，Servlet无法进行重定向</td><td>通过location.href来实现重定向的要求，地址值可以在js中定义也可以通过后台传递给前台</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript笔记</title>
      <link href="/2021/06/22/javaScript%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/06/22/javaScript%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><h4 id="基本-值-类型"><a href="#基本-值-类型" class="headerlink" title="基本(值)类型"></a>基本(值)类型</h4><ul><li><p>String：任意字符串</p></li><li><p>Number：任意数字</p></li><li><p>boolean：true/false</p></li><li><p>undefined：undefined</p></li><li><p>null：null</p></li></ul><h4 id="对象-引用-类型"><a href="#对象-引用-类型" class="headerlink" title="对象(引用)类型"></a>对象(引用)类型</h4><ul><li><p>Object：任意对象</p></li><li><p>Function：一种特别的对象（可以执行）</p></li><li><p>Array：一种特别的对象（数值下标，内部数据是有序的）</p></li><li><p>类型也为一个对象（类型对象） 根据类型创建的对象叫实例对象</p></li></ul><h4 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h4><h5 id="typeof："><a href="#typeof：" class="headerlink" title="typeof："></a><strong>typeof：</strong></h5><ul><li><p>​    判断返回值为字符串，因此使用为:typeof a===’undefined’</p></li><li><p>​    可以判断:undefined、数值、布尔值、字符串</p></li><li><p>​    不能判断:Object与null（typeof null值 返回的字符串为Object） Object与Array（typeof Array对象 返回值为Object）</p></li></ul><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof:"></a><strong>instanceof:</strong></h5><ul><li>​    判断对象（具体）的类型</li></ul><h5 id><a href="#" class="headerlink" title="===:"></a><strong>===:</strong></h5><ul><li><p>​    可以判断:undefined、null（判断的为值与类型是否相等,且默认undefined===null）</p></li><li><p>​    ps:==进行数字与字符串比较时，会将字符串转化为数字再进行比较</p></li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h4><h5 id="undefined和null的区别"><a href="#undefined和null的区别" class="headerlink" title="undefined和null的区别:"></a>undefined和null的区别:</h5><ul><li>undefined代表定义未赋值</li><li>null代表定义且赋了值 但值为null</li></ul><h5 id="什么时候使用null"><a href="#什么时候使用null" class="headerlink" title="什么时候使用null:"></a>什么时候使用null:</h5><ul><li>初始赋值时:表明该变量为一个对象时,可以使用null初始赋值占位</li><li>结束前:让变量成为垃圾对象（被回收）</li></ul><h5 id="严格区分变量类型和数据类型："><a href="#严格区分变量类型和数据类型：" class="headerlink" title="严格区分变量类型和数据类型："></a>严格区分变量类型和数据类型：</h5><p>数据的类型</p><ul><li>基本类型：保存的就是基本类型、数据</li><li>对象类型</li></ul><p>变量的类型（变量内存值的类型）</p><ul><li>基本类型：保存的就是基本类型、数据</li><li>引用类型：保存的为地址值（变量对堆内存中对象地址值的引用）</li></ul><h3 id="2-内存"><a href="#2-内存" class="headerlink" title="2.内存"></a>2.内存</h3><h4 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a><strong>什么是数据？</strong></h4><ul><li>存储在内存中代表特点信息的二进制</li><li>具有可读写可传递的基本特性</li><li>程序中所有操作的目标都是数据</li></ul><h4 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a><strong>什么是内存？</strong></h4><ul><li><p>内存是内存条通电后产生可存储数据的空间（临时的）</p></li><li><p>每一块小内存存储着两个数据（内部存储的数据、地址值数据）</p></li><li><p>栈：存储全局变量、局部变量</p></li><li><p>堆：存储对象（函数名为一个变量名在栈空间中）</p></li></ul><h4 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a><strong>什么是变量？</strong></h4><ul><li><p>可变化的量，由变量名和变量值组成</p></li><li><p>每个可变的量都在内存区占着一快小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据</p></li></ul><h4 id="内存、数据、变量三者之间的关系"><a href="#内存、数据、变量三者之间的关系" class="headerlink" title="内存、数据、变量三者之间的关系"></a><strong>内存、数据、变量三者之间的关系</strong></h4><ul><li><p>内存是用来存储数据的临时空间（相比硬盘读写快）</p></li><li><p>变量是内存的标识（目的就是对内存中的数据进行操作:读、写）</p></li></ul><h4 id="关于引用变量的一些问题"><a href="#关于引用变量的一些问题" class="headerlink" title="关于引用变量的一些问题"></a><strong>关于引用变量的一些问题</strong></h4><h5 id="1-两个引用变量指向同一对象"><a href="#1-两个引用变量指向同一对象" class="headerlink" title="1.两个引用变量指向同一对象"></a><strong>1.两个引用变量指向同一对象</strong></h5><p><code>var a=&#123;name:&quot;Tom&quot;&#125;;</code><br><code>var b=a;</code><br><code>console.log(b.name);//Tom</code><br><code>function fn(obj)&#123;</code><br>    <code>obj.name=&quot;Bob&quot;</code><br><code>&#125;</code><br><code>fn(a)</code><br><code>console.log(b.name);//Bob</code></p><p><strong>原因：</strong></p><ul><li><p>var b=a时只是将a的<strong>内存内容（只不过内存内容为一个地址值）</strong>保存到b中</p></li><li><p>而fn(a)只是将a做为<strong>实参</strong>赋值给obj对象（当然赋的值也是内存内容）</p></li><li><p>因此<strong>三个变量引用的都为同一个对象的地址值进行操作</strong></p></li></ul><hr><h5 id="2-两个引用变量指向不同对象"><a href="#2-两个引用变量指向不同对象" class="headerlink" title="2.两个引用变量指向不同对象"></a><strong>2.两个引用变量指向不同对象</strong></h5><p><code>var a=&#123;age:12&#125;</code><br><code>var b=a;</code><br><code>var a=&#123;name:&quot;Bob&quot;,age:14&#125;</code><br><code>console.log(b.age,a.age)//12 14</code><br><code>function fn(obj) &#123;</code><br>    <code>obj=&#123;age:15&#125;</code><br><code>&#125;</code><br><code>fn(a)</code><br><code>console.log(a.age)//14</code></p><p><strong>原因:</strong></p><ul><li><p><strong>当对象引用发生改变时 被引用对象和引用对象不是同一个对象</strong></p></li><li><p>fn<strong>函数</strong>执行完后内部的局部变量就会<strong>自动释放</strong>，一旦自动释放之后</p></li><li><p>obj对象就会成为垃圾对象，<strong>因此调用a时调用的是变量值为 {name:”Bob”,age:14} 的对象</strong></p></li><li><p>(说白了就是obj和a存储的不是同一个对象地址值 因此obj影响不了a)</p></li><li><p><strong>3.在js调用函数时传递变量参数时，是值传递还是引用传递？</strong></p></li><li><p>答：可能是值传递也可能是，引用传递（地址值）,取决于参数是否为对象</p></li></ul><h4 id="JS引擎管理内存的方式"><a href="#JS引擎管理内存的方式" class="headerlink" title="JS引擎管理内存的方式"></a>JS引擎管理内存的方式</h4><h5 id="1-内存生命周期"><a href="#1-内存生命周期" class="headerlink" title="1.内存生命周期"></a><strong>1.内存生命周期</strong></h5><ul><li>分配小内存空间，得到它的使用权</li><li>存储数据，可以反复进行操作</li><li>释放小内存空间</li></ul><h5 id="2-释放内存"><a href="#2-释放内存" class="headerlink" title="2.释放内存"></a><strong>2.释放内存</strong></h5><ul><li>局部变量:函数执行完自动释放</li><li>对象:成为垃圾对象–&gt;垃圾回收器回收</li></ul><h3 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h3><h4 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a><strong>什么是对象？</strong></h4><ul><li>多个数据的封装体（集合体）</li><li>用来保存多个数据的容器</li><li>一个对象代表现实中的一个事物，是该事物在编程中的抽象</li></ul><h4 id="为什么要用对象？"><a href="#为什么要用对象？" class="headerlink" title="为什么要用对象？"></a><strong>为什么要用对象？</strong></h4><ul><li>统一管理多个数据</li></ul><h4 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a><strong>对象的组成</strong></h4><ul><li><strong>属性：</strong></li><li>由属性名（字符串）和属性值（任意类型）组成</li><li>代表现实事物的状态数据</li><li><strong>方法：</strong></li><li>一种特殊的属性（属性值是方法）</li><li>代表事物的行为</li></ul><h4 id="如何访问对象内部数据"><a href="#如何访问对象内部数据" class="headerlink" title="如何访问对象内部数据"></a><strong>如何访问对象内部数据</strong></h4><ul><li><p>.属性名：编码简单，有时不能用</p></li><li><p>[‘属性名’]：编码麻烦，能通用</p><p>​    <strong>使用场景:</strong></p><p>​        1.当属性名包含特殊符号：- 空格时可以使用，而上者不行</p><p>​        2.当变量名不确定时,如:</p><p>​                                <code>var p=&#123;name:&#39;yanghan&#39;&#125;;</code></p><p>​                                <code>var c=&#39;name&#39;;</code></p><p>​                                <code>p.c;//无法获取p的属性yanghan,同时输出的为undefined</code></p><p>​                                <code>p[c];//能获取p的属性yanghan</code></p></li></ul><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h3><h4 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a><strong>什么是函数？</strong></h4><ul><li>实现特定功能的n条语句的封装体</li><li>只有函数是能执行的，其他类型的数据都不能执行</li></ul><h4 id="为什么要使用函数？"><a href="#为什么要使用函数？" class="headerlink" title="为什么要使用函数？"></a><strong>为什么要使用函数？</strong></h4><ul><li>提高代码复用</li><li>便于阅读交流（封装思想）</li></ul><h4 id="如何定义函数？"><a href="#如何定义函数？" class="headerlink" title="如何定义函数？"></a><strong>如何定义函数？</strong></h4><ul><li>函数声明：function xx(){}</li><li>表达式:var xx=function(){}</li></ul><h4 id="如何执行函数？"><a href="#如何执行函数？" class="headerlink" title="如何执行函数？"></a><strong>如何执行函数？</strong></h4><ul><li>test()：直接调用</li><li>obj.test()：通过对象调用</li><li>new test():new调用</li><li>test.call/apply(obj):让函数成为指定对象的方法进行调用</li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><h5 id="什么函数才是回调函数？"><a href="#什么函数才是回调函数？" class="headerlink" title="什么函数才是回调函数？"></a><strong>什么函数才是回调函数？</strong></h5><ul><li>自身定义的函数</li><li>你没调用该函数，但该函数自动执行了</li></ul><h5 id="常见的回调函数"><a href="#常见的回调函数" class="headerlink" title="常见的回调函数"></a><strong>常见的回调函数</strong></h5><ul><li>dom对象回调函数</li><li>定时器回调函数（定时器:循环定时器、一次性定时器）</li><li>ajax请求回调函数</li><li>生命周期回调函数</li></ul><h4 id="IIFE（立即执行调用函数表达式）"><a href="#IIFE（立即执行调用函数表达式）" class="headerlink" title="IIFE（立即执行调用函数表达式）"></a><strong>IIFE（立即执行调用函数表达式）</strong></h4><p>匿名函数自调用</p><p><code>( function()&#123;</code><br>    <code>var a=3;</code><br>    <code>console.log(a+3)</code><br><code>&#125;)()</code></p><p>作用:</p><p>​    实现隐藏</p><p>​    不会污染外部（全局）命名空间</p><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p><strong>什么是this?</strong></p><ul><li>任何函数本质都是通过某个对象来调用的，如果没指定就是window对象调用</li><li>所有函数内部都有一个变量this</li><li>它的值是调用函数的当前对象</li></ul><p><strong>如何确定this值?</strong></p><ul><li>test()：window</li><li>p.test()：p</li><li>new est()：创建对象</li><li>p.call(obj):obj</li></ul><hr><h1 id="函数高级"><a href="#函数高级" class="headerlink" title="函数高级"></a>函数高级</h1><h3 id="1-原型与原型链"><a href="#1-原型与原型链" class="headerlink" title="1.原型与原型链"></a>1.原型与原型链</h3><h4 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h4><p><strong>函数的prototype属性</strong></p><ul><li>每个函数都有prototype属性，它默认指向一个Object空对象(又称原型对象)</li><li>原型对象中又一个属性constructor，它指向函数对象</li></ul><p><strong>给原型对象添加方法</strong></p><ul><li>作用：函数的所有实例对象自动拥有原型中的属性(方法)</li></ul><h4 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h4><p><code>function Fn() &#123;//内部语句this.prototype=&#123;&#125;</code><br><code>&#125;</code><br><code>var fn = new Fn();//内部语句:fn.__proto__=Fn.prototype</code></p><ul><li>每个函数都一个prototype，即显式原型（属性）</li></ul><p><code>alert(Fn.prototype)</code></p><ul><li>每个实例对象都有一个__proto__，可称为隐式原型（属性）</li><li>对象隐式原型的值为其对应构造函数的显式原型的值</li></ul><p><code>alert(fn.__proto__)</code></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>访问一个对象的属性时</p><p>先在自身属性中查找查找，找到返回</p><p>如果没有再沿着__proto__这条链往上找，找到返回</p><p>如果最终没找到，返回undefined</p><p>别名：隐式原型链</p><p>作用：查找对象的属性（方法）</p><p><strong>补充</strong></p><p>函数的显式原型指向的对象默认是空Object实例对象(但Object不满足)</p><p>所有函数都是Function的实例(包括Function对象)</p><p>Object原型对象是原型链的尽头（原型对象的__proto__为null因此无法再进行查找）</p><h3 id="2-执行上下文与执行上下文栈"><a href="#2-执行上下文与执行上下文栈" class="headerlink" title="2.执行上下文与执行上下文栈"></a>2.执行上下文与执行上下文栈</h3><h3 id="3-作用域和作用链域"><a href="#3-作用域和作用链域" class="headerlink" title="3.作用域和作用链域"></a>3.作用域和作用链域</h3><h3 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的后端学习路线</title>
      <link href="/2021/06/16/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2021/06/16/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h4 id="第一阶段：Java基础知识-培养编程思维"><a href="#第一阶段：Java基础知识-培养编程思维" class="headerlink" title="第一阶段：Java基础知识(培养编程思维)"></a><strong>第一阶段：Java基础知识(培养编程思维)</strong></h4><blockquote><p>变量、数据类型、运算符</p><p>控制语句(循环嵌套多思考)</p><p>面向对象编程(转折点!作为初学者这块可能会很难!)</p><p>异常机制</p><p>Java常用类(API)</p><p>集合(代替数组 后期常用到)</p><p>iO流</p><p>多线程</p><p>网络编程</p></blockquote><h4 id="第二阶段：数据库阶段-后期都要连库操作"><a href="#第二阶段：数据库阶段-后期都要连库操作" class="headerlink" title="第二阶段：数据库阶段(后期都要连库操作)"></a><strong>第二阶段：数据库阶段(后期都要连库操作)</strong></h4><blockquote><p>MysSQL入门</p><p>DML（数据库操作语言）</p><p>DCL（数据库控制语言）</p><p>DDL（数据库定义语言）</p><p>单表查询</p><p>多表查询-内连接查询</p><p>多表查询-外连接查询</p><p>多表查询-子查询</p><p>视图</p><p>事务</p><p>索引</p><p>三大范式</p><p>存储过程</p></blockquote><h4 id="第三阶段：JDBC和GUi（学习MVC设计模式）"><a href="#第三阶段：JDBC和GUi（学习MVC设计模式）" class="headerlink" title="第三阶段：JDBC和GUi（学习MVC设计模式）"></a><strong>第三阶段：JDBC和GUi（学习MVC设计模式）</strong></h4><blockquote><p>GUI</p><p>JDBC及案例</p><p>使用properties读取属性文件</p><p>JDBC+GUI实现简易的程序（重点）</p></blockquote><h4 id="第四阶段：WEB前端-后端也需学一些前端知识-但没必要太过精通"><a href="#第四阶段：WEB前端-后端也需学一些前端知识-但没必要太过精通" class="headerlink" title="第四阶段：WEB前端(后端也需学一些前端知识 但没必要太过精通)"></a><strong>第四阶段：WEB前端(后端也需学一些前端知识 但没必要太过精通)</strong></h4><blockquote><p>HTML5</p><p>CSS3</p><p>JavaScript(可以选择精学)</p></blockquote><h4 id="第五阶段：JavaWeb"><a href="#第五阶段：JavaWeb" class="headerlink" title="第五阶段：JavaWeb"></a><strong>第五阶段：JavaWeb</strong></h4><blockquote><p>Tomcat与HTTF</p><p>Servlet(JavaWeb三大组件之一 spring框架底层技术需精学)</p><p>文件下载练习</p><p>JSP基础语法</p><p>EL</p><p>JSTL</p><p>Cookie</p><p>Session</p><p>Filter(JavaWeb三大组件之一)</p><p>listener(avaWeb三大组件之一)</p><p>MVC架构</p><p>JSON</p><p>Ajax</p><p>项目实战</p></blockquote><h4 id="第六阶段：框架"><a href="#第六阶段：框架" class="headerlink" title="第六阶段：框架"></a><strong>第六阶段：框架</strong></h4><blockquote><p>jquery(JavaScript的框架)</p><p>vue(JavaScript的框架)</p><p>SSM(常见的三大框架)</p></blockquote><p><strong>以上为个除了框架未学，其他均为个人大一所学的知识 知识全部从网上视频、书籍中所获取</strong></p><p><strong>能获取的资源有限，可能上述有些旧知识，请选择性参考!</strong></p><h6 id="可能此次总结不到位，此文章将持续更新"><a href="#可能此次总结不到位，此文章将持续更新" class="headerlink" title="可能此次总结不到位，此文章将持续更新!"></a><strong>可能此次总结不到位，此文章将持续更新!</strong></h6>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA的安装和开发工具的选择</title>
      <link href="/2021/06/16/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/"/>
      <url>/2021/06/16/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h4 id="JDK的安装"><a href="#JDK的安装" class="headerlink" title="JDK的安装"></a>JDK的安装</h4><p><strong>首先JDK的下载:</strong></p><p>去官网下载相应的JDK版本，这边推荐下载<strong>JDK的解压版</strong> 下载完配置完环境即可用，</p><p>不需要时删除即可,如果需要更改版本直接修改配置环境即可。</p><p>现在市面上用的最多的jdk版本为jdk8,因此下载推荐下载jdk8或者之上的版本</p><p><strong>环境变量的配置:</strong></p><p>1.此电脑→属性→高级系统设置→高级</p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img1.png"></p><p><img src="/image/img2.png"></p><p>2.选择环境变量→新建一个系统变量</p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img3-1624098983658.png"></p><p>变量名为<strong>JAVA_HOME</strong>  变量值为<strong>JAVA的绝对路径</strong></p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img4-1624098999268.png"></p><p>3.双击path→新建一个环境变量</p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img5.png"></p><p>4.给path添加一个新的环境变量名为:<strong>%JAVA_HOME%\bin</strong></p><p><img src="/images/JAVA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/img6.png"></p><p><u>ps:如果电脑不支持双击进入编辑界面 可以直接在path的值中添加：%JAVA_HOME%\bin;</u></p><h4 id="开发工具的选择"><a href="#开发工具的选择" class="headerlink" title="开发工具的选择"></a>开发工具的选择</h4><p>这里强烈不推荐eclipse!时代在前进而不是倒退,既然有比eclipse更强的<strong>idea</strong></p><p>为什么不用呢？所以推荐使用<strong>idea idea</strong>有着更方便的快捷键 有着更人性化的</p><p>设置。但完整版需付费 因此需动动小手破解一下</p><p>链接：<a href="https://pan.baidu.com/s/1HkUheAc21iyidsc5yGTkTA">https://pan.baidu.com/s/1HkUheAc21iyidsc5yGTkTA</a><br>提取码：lcbn </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
